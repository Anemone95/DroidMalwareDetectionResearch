<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.20">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.lstframe{margin:auto;margin-bottom:2em}
</style>
<title>SPARTA! 
Static Program Analysis for
Reliable Trusted Apps
</title>
</head>
<body >
<!--HEVEA command line is: hevea -fix -exec xxdate.exe urlhref.hva manual.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">SPARTA!<br>
Static Program Analysis for
Reliable Trusted Apps</h1><h3 class="titlerest"><a href="http://types.cs.washington.edu/sparta/"><span style="font-family:monospace">http://types.cs.washington.edu/sparta/</span></a>
</h3><h3 class="titlerest">Version 1.0.2 (3 February 2016)<br>
</h3></td></tr>
</table><!--TOC chapter id="sec1" Contents-->
<h1 id="sec1" class="chapter">Contents</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#introduction">Chapter&#XA0;1&#XA0;&#XA0;Introduction</a>
<ul class="toc"><li class="li-toc">
<a href="#sec3">1.1&#XA0;&#XA0;Overview: malware detection and prevention tools</a>
</li><li class="li-toc"><a href="#sec%3Aincaseoftrouble">1.2&#XA0;&#XA0;In case of trouble</a>
</li></ul>
</li><li class="li-toc"><a href="#installation">Chapter&#XA0;2&#XA0;&#XA0;Installation and app setup</a>
<ul class="toc"><li class="li-toc">
<a href="#sec%3Arequirements">2.1&#XA0;&#XA0;Requirements</a>
</li><li class="li-toc"><a href="#sec%3Ainstall">2.2&#XA0;&#XA0;Install SPARTA</a>
</li><li class="li-toc"><a href="#sec%3Aantsetup">2.3&#XA0;&#XA0;Android App Setup</a>
</li></ul>
</li><li class="li-toc"><a href="#flow-checker">Chapter&#XA0;3&#XA0;&#XA0;Information Flow Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#sec%3Aflow-type-system">3.1&#XA0;&#XA0;Source and Sink annotations</a>
</li><li class="li-toc"><a href="#sec%3Apolyflowsources">3.2&#XA0;&#XA0;Polymorphism </a>
</li><li class="li-toc"><a href="#sec%3Apermissions">3.3&#XA0;&#XA0;Comparison to Android permissions</a>
</li><li class="li-toc"><a href="#sec%3Aflow-policy">3.4&#XA0;&#XA0;Flow Policy</a>
</li><li class="li-toc"><a href="#sec29">3.5&#XA0;&#XA0;Inference and defaults</a>
</li><li class="li-toc"><a href="#sec%3Awaringsuppression">3.6&#XA0;&#XA0;Warning suppression</a>
</li><li class="li-toc"><a href="#sec%3Aapispecs">3.7&#XA0;&#XA0;Annotating library API methods in stub files</a>
</li><li class="li-toc"><a href="#sec%3Astricter">3.8&#XA0;&#XA0;Stricter tests</a>
</li></ul>
</li><li class="li-toc"><a href="#intent-checker">Chapter&#XA0;4&#XA0;&#XA0;Intent Checker</a>
<ul class="toc"><li class="li-toc">
<a href="#component-map">4.1&#XA0;&#XA0;Inter-component communication</a>
</li><li class="li-toc"><a href="#intent-types">4.2&#XA0;&#XA0;Intent types</a>
</li></ul>
</li><li class="li-toc"><a href="#analyze-annotated-app">Chapter&#XA0;5&#XA0;&#XA0;How to Analyze an Annotated App</a>
<ul class="toc"><li class="li-toc">
<a href="#sec53">5.1&#XA0;&#XA0;Review the flow policy</a>
</li><li class="li-toc"><a href="#sec54">5.2&#XA0;&#XA0;Run the Information Flow Checker</a>
</li><li class="li-toc"><a href="#sec55">5.3&#XA0;&#XA0;Review <span style="font-family:monospace">@SuppressWarnings</span> justifications</a>
</li></ul>
</li><li class="li-toc"><a href="#analyze-unannotated-app">Chapter&#XA0;6&#XA0;&#XA0;How to Analyze an Unannotated App</a>
<ul class="toc"><li class="li-toc">
<a href="#sec%3Awrite-flow-policy">6.1&#XA0;&#XA0;Write a flow-policy file</a>
</li><li class="li-toc"><a href="#sec%3Areverse-engineering">6.2&#XA0;&#XA0;Run reverse-engineering tools</a>
</li><li class="li-toc"><a href="#verify-information-flow-security">6.3&#XA0;&#XA0;Verify information flow security</a>
</li></ul>
</li><li class="li-toc"><a href="#tutorial">Chapter&#XA0;7&#XA0;&#XA0;Tutorial</a>
<ul class="toc"><li class="li-toc">
<a href="#sec77">7.1&#XA0;&#XA0;Set up</a>
</li><li class="li-toc"><a href="#sec78">7.2&#XA0;&#XA0;Drafting a flow policy</a>
</li><li class="li-toc"><a href="#sec79">7.3&#XA0;&#XA0;Correcting Annotations</a>
</li><li class="li-toc"><a href="#sec80">7.4&#XA0;&#XA0;Adding Annotations</a>
</li><li class="li-toc"><a href="#sec85">7.5&#XA0;&#XA0;Correctly annotated app</a>
</li></ul>
</li></ul><hr>
<!--TOC chapter id="introduction" Introduction-->
<h1 id="introduction" class="chapter">Chapter&#XA0;1&#XA0;&#XA0;Introduction</h1><!--SEC END --><p>SPARTA is a research project at the University of Washington funded by the DARPA
Automated Program Analysis for Cybersecurity (APAC) program.</p><p>SPARTA aims to detect certain types of malware in Android applications, or
to verify that the app contains no such malware. SPARTA&#X2019;s verification
approach is type-checking. The developer states a security property and
annotates the source code with type qualifiers that express that security
property. Then a pluggable type-checker&#XA0;[<a href="#PapiACPE2008">PAC+08</a>, <a href="#DietlDEMS2011">DDE+11</a>] verifies the type
qualifiers, and thus verifies that the program satisfies the security
property.</p><p>You can find the latest version of this manual in the <span style="font-family:monospace">sparta-code</span> version
control repository, in directory <span style="font-family:monospace">sparta-code/docs</span>. Alternately, you can
find it in a SPARTA release at
<a href="http://types.cs.washington.edu/sparta/release/"><span style="font-family:monospace">http://types.cs.washington.edu/sparta/release/</span></a>, though that may not
be as up-to-date.</p>
<!--TOC section id="sec3" Overview: malware detection and prevention tools-->
<h2 id="sec3" class="section">1.1&#XA0;&#XA0;Overview: malware detection and prevention tools</h2><!--SEC END --><p>The SPARTA toolset contains two types of tools: reverse engineering tools to find potentially
dangerous code in an Android app, and a tool to statically verify
information flow properties.</p><p>The reverse engineering tools to find potentially dangerous code can be run on
arbitrary unannotated Android source code. Those tools give no guarantees,
but they direct the analyst&#X2019;s attention to suspicious locations
in the source code.</p><p>By contrast, the tools to statically verify information flow require a person to write
the information flow properties of the program, primarily as source code
annotations. For instance, the type of an object that contains data that came from the
camera and is destined for the network would be annotated with </p><pre class="verbatim">@Source(CAMERA) @Sink(INTERNET)
</pre><p>The SPARTA tool set was developed with two different types of users in mind. 
1.) Application vendors, who are the original authors of an app that submit the app 
to an app store for a security review. 2.) App analysts, or verification engineers, 
who work on behalf of the app store
to verify that apps meant specific security properties before they are accepted. </p><p>Depending on the corporation between these two parties, they may use the SPARTA tools 
in two different ways.</p><ul class="itemize"><li class="li-itemize">
Ideally, the application vendor, who understands the source code,
writes information flow annotations such as <span style="font-family:monospace">@Source</span> in the source
code, iterating until the static information flow tool issues no warnings.<p>In this case, the analyst merely re-runs the static information flow tool
to confirm the vendor&#X2019;s work. This shows that there are no undesired
information flows in the program.</p><p>Chapter&#XA0;<a href="#analyze-annotated-app">5</a> explains how to use the SPARTA tools for
this scenario.</p></li><li class="li-itemize">If the application vendor delivers an unannotated program, then the
analyst must understand the program well enough to annotate it and then
annotate it.<p>In this case, it is most efficient to first run the reverse engineering
tools to detect suspicious code. Those tools might reveal unacceptable
code: either malware or code that the vendor
should rewrite in a clearer or safer way. If the suspicious code
detection tools do not reveal problems so severe that the app should be
rejected, then they help to guide the next step. The analyst writes
information flow annotations and runs the information
flow tool until either the analyst has found a vulnerability or the lack
of tool warnings indicates there is no vulnerability.</p><p>Chapter&#XA0;<a href="#analyze-unannotated-app">6</a> explains how to use the SPARTA tools for
this scenario.
</p></li></ul>
<!--TOC section id="sec:incaseoftrouble" In case of trouble-->
<h2 id="sec:incaseoftrouble" class="section">1.2&#XA0;&#XA0;In case of trouble</h2><!--SEC END --><p>
If you have trouble, please email either
<span style="font-family:monospace">sparta@cs.washington.edu</span>
(developers mailing list) or
<span style="font-family:monospace">sparta-users@cs.washington.edu</span> (users
mailing list) and we will try to help.
</p><hr>
<!--TOC chapter id="installation" Installation and app setup-->
<h1 id="installation" class="chapter">Chapter&#XA0;2&#XA0;&#XA0;Installation and app setup</h1><!--SEC END --><p>
This chapter describes how to install the SPARTA tools
(Section&#XA0;<a href="#sec%3Ainstall">2.2</a>) and how to prepare an Android app to run the
SPARTA tools. (Section&#XA0;<a href="#sec%3Aantsetup">2.3</a>).</p>
<!--TOC paragraph id="sec6" Checker Framework-->
<h5 id="sec6" class="paragraph">Checker Framework</h5><!--SEC END --><ul class="itemize"><li class="li-itemize">
If you are using the released version of SPARTA, follow the installation instructions in the manual: 
<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#installation"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#installation</span></a>
</li><li class="li-itemize">If you are using the development version of SPARTA, follow Section 25.3 from the Checker Framework manual (Building from source.)
</li><li class="li-itemize">For both versions, as described in the installation instructions, set the <span style="font-family:monospace">CHECKERFRAMEWORK</span>
environment variable to <span style="font-family:monospace">.../checker-framework/</span>
</li></ul>
<!--TOC section id="sec:requirements" Requirements-->
<h2 id="sec:requirements" class="section">2.1&#XA0;&#XA0;Requirements</h2><!--SEC END -->
<!--TOC paragraph id="sec8" Java 7-->
<h5 id="sec8" class="paragraph">Java 7</h5><!--SEC END --><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">.../jdk1.7.0/bin</span> must be on your path.
</li><li class="li-itemize"><span style="font-family:monospace">JAVA_HOME</span> should be set to <span style="font-family:monospace">.../jdk1.7.0</span>.
</li></ul>
<!--TOC paragraph id="sec9" Ant-->
<h5 id="sec9" class="paragraph">Ant</h5><!--SEC END --><ul class="itemize"><li class="li-itemize">
Ant version 1.8.2 or later
</li></ul>
<!--TOC paragraph id="sec10" Android SDK-->
<h5 id="sec10" class="paragraph">Android SDK</h5><!--SEC END --><ul class="itemize"><li class="li-itemize">
Android API version 15 or later
</li></ul><ol class="enumerate" type=1><li class="li-enumerate">
Install the Android SDK to some directory. 
</li><li class="li-enumerate">Set <span style="font-family:monospace">ANDROID_HOME</span> to the directory where you installed the
Android SDK.
</li><li class="li-enumerate">Download the <span style="font-family:monospace">android-15</span> target by running <span style="font-family:monospace">$ANDROID_HOME/tools/android</span>
</li></ol>
<!--TOC section id="sec:install" Install SPARTA-->
<h2 id="sec:install" class="section">2.2&#XA0;&#XA0;Install SPARTA</h2><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">Obtain the source code for the SPARTA tools, either from its version
control repository or from a packaged release.<ul class="itemize"><li class="li-itemize">
To obtain from the version control repository, run
<pre class="verbatim">git clone git@github.com:typetools/sparta.git  
</pre></li><li class="li-itemize"><p>The source code is also available as a part of the release:
download the SPARTA release from
<a href="http://types.cs.washington.edu/sparta/release/"><span style="font-family:monospace">http://types.cs.washington.edu/sparta/release/</span></a>. </p><p>Then, unpack the archive.
</p></li></ul></li><li class="li-enumerate">Build the SPARTA tools by compiling the source code:
<pre>
ant jar
</pre></li><li class="li-enumerate">As a sanity check of the installation, run<pre>
ant all-tests
</pre><p>You should see &#X201C;<span style="font-family:monospace">BUILD SUCCESSFUL</span>&#X201D; at the end.</p></li></ol>
<!--TOC section id="sec:antsetup" Android App Setup-->
<h2 id="sec:antsetup" class="section">2.3&#XA0;&#XA0;Android App Setup</h2><!--SEC END --><p>This section explains how to set up an Android application for analysis with the SPARTA tools.
</p><ol class="enumerate" type=1><li class="li-enumerate">Ensure the following environment variables are set. <ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">CHECKERFRAMEWORK</span> is the
<span style="font-family:monospace">.../checker-framework/</span> directory</li><li class="li-itemize"><span style="font-family:monospace">SPARTA_CODE</span> is the <span style="font-family:monospace">.../sparta-code</span> directory</li><li class="li-itemize"><span style="font-family:monospace">ANDROID_HOME</span> is the <span style="font-family:monospace">.../android-sdk</span> directory</li></ul></li><li class="li-enumerate">Update the app configuration by running the following command in the main directory of the
app.
<pre class="verbatim">$ANDROID_HOME/tools/android update project --path .
</pre></li><li class="li-enumerate">Copy the file <span style="font-family:monospace">sparta.jar</span> generated in Section&#XA0;<a href="#sec%3Ainstall">2.2</a> to the
directory <span style="font-family:monospace">libs/</span> in the main directory of the app. If that folder doesn&#X2019;t
exist it must be created.</li><li class="li-enumerate">Build the app<pre class="verbatim">ant release
</pre><p>If the app does not build with the above command, then the SPARTA tool set will 
not be able to analyze the app. Below are two common compilation issues and
solutions.
</p><ul class="itemize"><li class="li-itemize">
Most Android apps will rely on an auto-generated <span style="font-family:monospace">R.java</span> file
in the <span style="font-family:monospace">/gen</span> directory of the project. This will only be generated
if there are no errors in the project. There may be errors in the
resources (<span style="font-family:monospace">.../res</span> directory) that could cause <span style="font-family:monospace">R.java</span> to not be
generated.</li><li class="li-itemize">Additionally, if the app depends on an external <span style="font-family:monospace">.jar</span> file, it will compile
in Eclipse but not with Ant. All dependent <span style="font-family:monospace">.jar</span> files must be in the
<span style="font-family:monospace">libs/</span> directory.
</li></ul></li><li class="li-enumerate">Add the SPARTA build targets to the end of the <span style="font-family:monospace">build.xml</span>
file, just above <code>&lt;/project&gt;</code>.<pre class="verbatim">    &lt;property name="checker-framework" value="${env.CHECKERFRAMEWORK}"/&gt;
    &lt;property name="sparta-code" value="${env.SPARTA_CODE}"/&gt;

    &lt;dirname property="checker-framework_dir" file="${checker-framework}/checker-framework" /&gt;
    &lt;dirname property="sparta-code_dir" file="${sparta-code}/sparta-code" /&gt;

    &lt;import file="${sparta-code_dir}/build.include.xml" /&gt;
    &lt;property name="flowPolicy" value="flow-policy"/&gt;
    &lt;property name="componentMap" value="component-map"/&gt;
</pre></li></ol>
<!--TOC subsubsection id="sec13" Using Eclipse to analyze apps-->
<h4 id="sec13" class="subsubsection">Using Eclipse to analyze apps</h4><!--SEC END --><p>
To use Eclipse to look at and build the code, perform these 
steps:
</p><ul class="itemize"><li class="li-itemize">
Import the projects the app. <span style="font-family:monospace">Import </span>&#X2192;<span style="font-family:monospace"> Existing Android Code 
Into Workspace</span></li><li class="li-itemize">Make sure
<span style="font-family:monospace">Project Properties </span>&#X2192;<span style="font-family:monospace"> Android </span>&#X2192;<span style="font-family:monospace"> Android
version #</span> is checked</li><li class="li-itemize">Check that
<span style="font-family:monospace">Project Properties </span>&#X2192;<span style="font-family:monospace"> Java Build Path </span>&#X2192;<span style="font-family:monospace">
Libraries </span>&#X2192;<span style="font-family:monospace"> Android version #</span> appears</li><li class="li-itemize">Add sparta.jar to the apps build path</li><li class="li-itemize">Right click on the build.xml file and select <span style="font-family:monospace">Run as </span>&#X2192;<span style="font-family:monospace"> 
External Tools Configurations...</span>. In the <span style="font-family:monospace">Main</span> tab add <span style="font-family:monospace">check-flow</span> to the 
Arguments box. In the <span style="font-family:monospace">Environment</span> tab, add the <span style="font-family:monospace">CHECKERFRAMEWORK</span> and 
<span style="font-family:monospace">SPARTA_CODE</span> variables. </li></ul><hr>
<!--TOC chapter id="flow-checker" Information Flow Checker-->
<h1 id="flow-checker" class="chapter">Chapter&#XA0;3&#XA0;&#XA0;Information Flow Checker</h1><!--SEC END --><p>
This chapter describes the Information Flow Checker, a type-checker that 
tracks information flow through your program.
The Information Flow Checker does pluggable type-checking of an information flow type
system. It is implemented using the Checker Framework. This chapter is
logically a chapter of the 
Checker Framework Manual (<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/checkers-manual.html</span></a>).
Therefore, in order to understand this chapter, you should first read
chapters 1&#X2013;2 of the Checker Framework Manual, and you should at least skim
chapters 18&#X2013;21 (generics through libraries) and 24&#X2013;25 (FAQ and
troubleshooting). </p><p>To use the Information Flow Checker, a programmer must supply two types of
information:</p><ul class="itemize"><li class="li-itemize">
A flow policy that expresses what information flows the program is allowed
to have.  For example, a program might be allowed to send location
information to the network, but not allowed to access contacts nor to send
SMS messages. The flow policy is primarily derived from the program&#X2019;s user
documentation. Section&#XA0;<a href="#sec%3Aflow-policy">3.4</a> describes how to write a flow
policy.
</li><li class="li-itemize">
Type qualifiers written on (some of) the variables in the program. The
type qualifiers indicate where the variable&#X2019;s value came from and where it
might go to.
</li></ul><p>When you run the Information Flow Checker, it verifies that the annotations in the
program are consistent with what the program&#X2019;s code does, and that the
annotations are consistent with the flow policy. This gives a guarantee
that the program has no information flow beyond what is expressed in the
flow policy and type annotations.</p>
<!--TOC section id="sec:flow-type-system" Source and Sink annotations-->
<h2 id="sec:flow-type-system" class="section">3.1&#XA0;&#XA0;Source and Sink annotations</h2><!--SEC END --><p>The type qualifier <span style="font-family:monospace">@Source</span> on a variable&#X2019;s
type indicates what sensitive sources might affect the variable&#X2019;s value.
The type qualifier <span style="font-family:monospace">@Sink</span> indicates where (information computed from) the
value might be output.
These qualifiers can be used on any occurrence
of a type, including in type parameters, object instantiation, and cast types.</p><p>As an example, consider the declaration</p><pre class="verbatim">    @Source(LOCATION) @Sink(INTERNET) double loc;
</pre><p>The type of variable <span style="font-family:monospace">loc</span> is <span style="font-family:monospace">@Source(LOCATION) @Sink(INTERNET)
double</span>.
The <span style="font-family:monospace">@Source(LOCATION)</span> qualifier indicates that the
value of <span style="font-family:monospace">loc</span> might have been derived from
location information.
Similarly, the qualifier <span style="font-family:monospace">@Sink(INTERNET)</span> indicates that
<span style="font-family:monospace">loc</span> might be output to the network. It is also
possible that the data has already been output.
A programmer typically writes either <span style="font-family:monospace">@Source</span> or <span style="font-family:monospace">@Sink</span>, but not both, as explained
in Section&#XA0;<a href="#sec%3Asystem%3Adefaults">3.5</a>. </p><p>The arguments to <span style="font-family:monospace">@Source</span> and <span style="font-family:monospace">@Sink</span> are one or more permissions
drawn from our enriched permission system (Section&#XA0;<a href="#sec%3Apermissions">3.3</a>).
The rarely-used special constant <span style="font-family:monospace">ANY</span> denotes the set of all sources or the set of all
sinks.
</p>
<!--TOC subsection id="sec:flow-anno-syntax" Syntax-->
<h3 id="sec:flow-anno-syntax" class="subsection">3.1.1&#XA0;&#XA0;Syntax</h3><!--SEC END --><p>
The source and sink qualifiers are type annotations that can be used on any type use. They have a single attribute, an array of Strings, that represent the permissions. The Strings must start with the string value of a constant in the FlowPermission enum; a class with a static string constant, FlowPermissionString, can be statically imported and used for this purpose. They can be optionally parameterized as shown below:</p><pre class="verbatim">PERMISSION(param1, param1)
</pre><p>Some examples:</p><pre class="verbatim">@Source(FILESYSTEM)
@Source(INTERNET+"(uw.edu)")
@Sink({WRITE_SMS, WRITE_CONTACTS})
</pre>
<!--TOC subsection id="sec:subtyping" Subtyping-->
<h3 id="sec:subtyping" class="subsection">3.1.2&#XA0;&#XA0;Subtyping</h3><!--SEC END --><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center"><img src="manual001.png"><img src="manual002.png"></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3.1: Partial qualifier hierarchy for flow source and flow sink type
qualifiers, expressed as Java annotations <span style="font-family:monospace">@Source</span> and <span style="font-family:monospace">@Sink</span>.</td></tr>
</table></div>
<a id="fig:flow-hierarchy"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>A type qualifier hierarchy indicates
which assignments, method calls, and overridings are legal, according to
standard object-oriented typing rules.
Figure&#XA0;<a href="#fig%3Aflow-hierarchy">3.1</a> shows parts of the <span style="font-family:monospace">@Source</span> and
<span style="font-family:monospace">@Sink</span> qualifier hierarchies.</p><p><span style="font-family:monospace">@Source(</span><span style="font-style:italic">B</span><span style="font-family:monospace">)</span> is a subtype of <span style="font-family:monospace">@Source(</span><span style="font-style:italic">A</span><span style="font-family:monospace">)</span> iff <span style="font-style:italic">B</span> is a subset of <span style="font-style:italic">A</span>.
For example, <span style="font-family:monospace">@Source(INTERNET)</span> is a subtype of <span style="font-family:monospace">@Source({INTERNET, LOCATION})</span>.
This rule reflects the fact that the <span style="font-family:monospace">@Source</span> annotation
places an upper bound on the set of sensitive sources that were actually
used to compute the value.
If the type of <span style="font-family:monospace">x</span> contains <span style="font-family:monospace">@Source({INTERNET, LOCATION})</span>, then the value
in <span style="font-family:monospace">x</span> might have been derived from both <span style="font-family:monospace">INTERNET</span> and <span style="font-family:monospace">LOCATION</span> data, or
only from <span style="font-family:monospace">INTERNET</span>, or only from <span style="font-family:monospace">LOCATION</span>, or from no
sensitive source at all.
</p><p>The opposite rule applies for sinks:
<span style="font-family:monospace">@Sink(</span><span style="font-style:italic">B</span><span style="font-family:monospace">)</span> is a subtype of <span style="font-family:monospace">@Sink(</span><span style="font-style:italic">A</span><span style="font-family:monospace">)</span> iff <span style="font-style:italic">A</span> is a subset of <span style="font-style:italic">B</span>.
The type <span style="font-family:monospace">@Sink({INTERNET, LOCATION})</span> indicates that
the value is permitted to flow to both <span style="font-family:monospace">INTERNET</span> and <span style="font-family:monospace">FILESYSTEM</span>. This
is a subtype of <span style="font-family:monospace">@Sink(INTERNET)</span>, as the latter type provides fewer routes through which the information may be
leaked.</p>
<!--TOC section id="sec:polyflowsources" Polymorphism -->
<h2 id="sec:polyflowsources" class="section">3.2&#XA0;&#XA0;Polymorphism </h2><!--SEC END --><p>Information flow type qualifiers interact seamlessly with parametric polymorphism (Java
generics). For example, a programmer can declare</p><pre class="verbatim">    List&lt;@Source(CONTACTS) @Sink(SMS) String&gt; myList;
</pre><p>Here, the elements of <span style="font-family:monospace">myList</span> are strings
that are obtained from <span style="font-family:monospace">CONTACTS</span> and that may flow to <span style="font-family:monospace">SMS</span>.</p><p>The Information Flow Checker also supports qualifier polymorphism, in
which the type qualifiers can change independently of the underlying type.
This allows a programmer to write a generic method that can operate on values of
any information flow type.
For example, if a method is declared as
<span style="font-family:monospace">@PolySource int f(@PolySource int x)</span>, then it can be called on an <span style="font-family:monospace">int</span>
with any flow sources, and the result has exactly the same sources as the
input. This can be viewed as a declaration and two uses of a type
qualifier variable. The implicit type qualifier variables are
automatically instantiated by the Information Flow Checker at the point of use.</p><p>For brevity,
the additional
annotation <span style="font-family:monospace">@PolyFlow</span> can be written on a class or method declaration to indicate that
all contained parameters and return types should be annotated as <span style="font-family:monospace">@PolySource
@PolySink</span>. <span style="font-family:monospace">@PolyFlow</span> does not override explicitly-written annotations as explained
in Section&#XA0;<a href="#sec%3Apolyflow">3.5.4</a>.</p><p>Parametric polymorphism, qualifier polymorphism, and regular Java types can
be used together. The type system combines the
qualifier variables and the Java types into a complete qualified type.</p><p>See section &#X201C;<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#qualifier-polymorphism">Qualifier polymorphism</a>&#X201D; in the Checker Framework Manual. </p>
<!--TOC subsection id="sec19" Receiver polymorphism-->
<h3 id="sec19" class="subsection">3.2.1&#XA0;&#XA0;Receiver polymorphism</h3><!--SEC END --><p>Receiver polymorphism restricts the return and/or parameter qualifier types of a method to be exactly 
the qualifier type of the receiver. 
For example, the StringBuffer append method uses this sort of polymorphism to restrict they type of strings that can be appended. For example,</p><pre class="verbatim">StringBuffer buffer = (@Source(USER_INPUT) StringBuffer) new StringBuffer();
@Source(READ_SMS) String smsMessage = getSMS();
buffer.append(smsMessage);  // illegal
buffer.append(getUserInput());  // legal
 </pre><p>Parameters, returns, and receivers are annotated with <span style="font-family:monospace">@PolySourceR</span> or <span style="font-family:monospace">@PolySinkR</span> to indicate this.</p>
<!--TOC section id="sec:permissions" Comparison to Android permissions-->
<h2 id="sec:permissions" class="section">3.3&#XA0;&#XA0;Comparison to Android permissions</h2><!--SEC END --><p>The Information Flow Checker&#X2019;s permissions are finer-grained than standard Android manifest permissions
in two ways. First, Android permits any flow
between any pair of permissions in the manifest &#X2014; that is, an Android
program may use any resource
mentioned in the manifest in an arbitrary way. Second,
the Information Flow Checker refines Android&#X2019;s permissions, as
we now discuss.</p><p>The Information Flow Checker&#X2019;s permissions are not enforced at run time as Android
permissions are (the latter potentially resulting in an exception during execution).
Rather, they are statically guaranteed at compile time. Even if an app
inherited a permission from another app with the same sharedUserId, 
the Information Flow Checker will require that permission to be listed in the flow policy. </p>
<!--TOC subsubsection id="sec:parameterized-permissions" Restricting existing permissions-->
<h4 id="sec:parameterized-permissions" class="subsubsection">Restricting existing permissions</h4><!--SEC END --><p>Android&#X2019;s <span style="font-size:small">INTERNET</span> permission represents all reachable 
hosts on the Internet, which is too coarse-grained to express the
developer&#X2019;s intention. The Information Flow Checker allows this permission to be parameterized with a domain name,
as in <span style="font-size:small">INTERNET(&#X201C;*.google.com&#X201D;)</span>.
Other permissions can be parameterized in a similar style in which 
the meaning of the optional parameter varies based on the permission 
it qualifies.
For example, a parameter to <span style="font-size:small">FILESYSTEM</span> represents a file or
directory name or wildcard, whereas the 
parameter to <span style="font-size:small">SEND_SMS</span> represents the number that receives the
SMS.</p><p>Other permissions that need to be parameterized include 
<span style="font-size:small">CONTACTS</span>, <span style="font-size:small">*_EXTERNAL_FILESYSTEM</span>,
<span style="font-size:small">NFC</span>, <span style="font-size:small">*_SMS</span>, and <span style="font-size:small">USE_SIP</span>, plus several of those
described in Section&#XA0;<a href="#sec%3Anew-permissions">3.3</a>, such as <span style="font-size:small">USER_INPUT</span> to
distinguish sensitive from non-sensitive user input.</p>
<!--TOC subsubsection id="sec22" Sinks and sources for additional resources-->
<h4 id="sec22" class="subsubsection">Sinks and sources for additional resources</h4><!--SEC END --><p>
<a id="sec:new-permissions"></a></p><p>The Information Flow Checker adds additional sources and sinks to the Android permissions.
For example, the Information Flow Checker requires 
a permission to retrieve data from the accelerometer, which can indicate the user&#X2019;s
physical activity, and to write to the logs, which a colluding app could potentially read.
Table&#XA0;<a href="#tab%3Aperms">3.1</a> lists
the additional sources and sinks.
We selected and refined these by examining the Android
API and Android programs, and it is easy to add additional ones.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Table 3.1: Additional permissions used by the Information Flow Checker, beyond the built-in 130 Android permissions.</td></tr>
</table></div>
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td class="hbar" colspan=3></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-weight:bold">Sources</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-weight:bold">Sinks</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-weight:bold">Both source and sink</span></td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >ACCELEROMETER</td><td style="text-align:left;white-space:nowrap" >DISPLAY</td><td style="text-align:left;white-space:nowrap" >CAMERA_SETTINGS</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >BUNDLE</td><td style="text-align:left;white-space:nowrap" >SPEAKER</td><td style="text-align:left;white-space:nowrap" >CONTENT_PROVIDER</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >MEDIA</td><td style="text-align:left;white-space:nowrap" >WRITE_CLIPBOARD</td><td style="text-align:left;white-space:nowrap" >DATABASE</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >PHONE_NUMBER</td><td style="text-align:left;white-space:nowrap" >WRITE_EMAIL</td><td style="text-align:left;white-space:nowrap" >FILESYSTEM</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >RANDOM</td><td style="text-align:left;white-space:nowrap" >WRITE_LOGS</td><td style="text-align:left;white-space:nowrap" >INTENT</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >READ_CLIPBOARD</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >PARCEL</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >READ_EMAIL</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >PROCESS_BUILDER</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >READ_TIME</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >SECURE_HASH</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >REFLECTION</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >SHARED_PREFERENCES</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >SENSOR</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >SYSTEM_PROPERTIES</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >USER_INPUT</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>
<a id="tab:perms"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC section id="sec:flow-policy" Flow Policy-->
<h2 id="sec:flow-policy" class="section">3.4&#XA0;&#XA0;Flow Policy</h2><!--SEC END --><p>A flow policy is a list of all the information flows that are permitted to occur
in an application.
A flow policy file expresses a flow policy, as a list of <span style="font-size:small"><span style="font-style:italic">flowsource</span></span><sup><span style="font-size:small">*</span></sup>&#X2192;<span style="font-size:small"><span style="font-style:italic">flowsink</span></span><sup><span style="font-size:small">*</span></sup> pairs.
Just as the Android manifest lists all the permissions that an app uses,
the flow policy file lists the flows among permissions and other sensitive 
locations. </p>
<!--TOC subsection id="sec24" Semantics of a Flow Policy-->
<h3 id="sec24" class="subsection">3.4.1&#XA0;&#XA0;Semantics of a Flow Policy</h3><!--SEC END --><p>
<a id="sec:undsiredflows"></a>
The Information Flow Checker guarantees that there is no information
flow except for what is explicitly permitted by the policy file. If a user writes a type that is
not permitted by the policy file, then the Information Flow Checker issues a warning
even if all types in program otherwise typecheck.</p><p>For example, this variable declaration</p><pre>
@Source(CAMERA) @Sink(INTERNET) Video video = ...
</pre><p>is illegal unless the the policy file contains:</p><pre>
CAMERA -&gt; INTERNET
</pre><p>Here is another example.
The flow policy file contains:
</p><pre>
  ACCOUNTS      -&gt; EXTERNAL_STORAGE, FILESYSTEM
  ACCELEROMETER -&gt; EXTERNAL_STORAGE, FILESYSTEM, INTERNET
</pre><p>The following variable declarations are permitted:
</p><pre>
  @Source(ACCOUNTS) @Sink(EXTERNAL_STORAGE) Account acc = ...
  @Source(ACCELEROMETER, ACCOUNTS)
  @Sink(EXTERNAL_STORAGE, FILE_SYSTEM) int accel = ...
</pre><p>The following definitions would generate &#X201C;forbidden flow&#X201D; errors:
</p><pre class="verbatim">  @Source(ACCOUNTS) @Sink(@INTERNET) Account acc = ...
  @Source({ACCELEROMETER, ACCOUNTS})
  @Sink({EXTERNAL_STORAGE, FILESYSTEM, INTERNET})
</pre><!--TOC subsubsection id="sec25" Transitivity and the flow policy file-->
<h4 id="sec25" class="subsubsection">Transitivity and the flow policy file</h4><!--SEC END --><p>
<a id="sec:flow-policy-transitivity"></a>
The flow policy file indicates specific permitted information flows. It
may be possible to combine these flows.
For example, a policy that permits
<span style="font-size:small">CAMERA</span>&#X2192;<span style="font-size:small">FILESYSTEM</span> and <span style="font-size:small">FILESYSTEM</span>&#X2192;<span style="font-size:small">INTERNET</span>
will implicitly allow the flow <span style="font-size:small">CAMERA</span>&#X2192;<span style="font-size:small">INTERNET</span>,
because the application may record from the camera into a file
and then send the contents of the file over the network.
The Information Flow Checker forbids such implied flows: the developer is required to write
the transitive flow in the flow policy file, which requires the developer
to justify its purpose or convince the app store that the flow is not used.
</p><!--TOC subsubsection id="sec26" Parameters and the flow policy file-->
<h4 id="sec26" class="subsubsection">Parameters and the flow policy file</h4><!--SEC END --><p>
<a id="sec:flow-policy-parameterized"></a>
The flow policy file allows for parameterized sources and sinks. Users
are allowed to add parameters to sources and sinks, but these are optional.
Sources and sinks without parameters default to a parameter of ("*") , a 
wildcard subsuming all permissions of the given type.<br>
</p><p>Here are examples of a parameterized sources or sinks, respectively.
The flow policy contains:
</p><pre>
  FILESYSTEM("/home/user") -&gt; INTERNET
  INTERNET("mydomain.org") -&gt; INTERNET
  ACCOUNTS      -&gt; EXTERNAL_STORAGE("/tmp/*"), FILESYSTEM("/usr/bin/output")
  ACCELEROMETER -&gt; EXTERNAL_STORAGE("/tmp/*"), FILESYSTEM("/usr/bin/output"), INTERNET("mydomain.org")
</pre><p>Here are examples of both sources and sinks parameterized.
The flow policy contains:
</p><pre>
  FILESYSTEM("/home/user") -&gt; INTERNET("mydomain.org")
  INTERNET("mydomain.org") -&gt; INTERNET("mydomain.org")
</pre>
<!--TOC subsection id="sec27" Syntax of a Flow Policy File-->
<h3 id="sec27" class="subsection">3.4.2&#XA0;&#XA0;Syntax of a Flow Policy File</h3><!--SEC END --><p>Each line of a policy file specifies a permitted flow from a source to one
or more sinks. For example,
<span style="font-family:monospace">MICROPHONE -&gt; INTERNET</span> implies that
MICROPHONE data is always allowed to flow to INTERNET.
The source or sink must be a member of the enum
<span style="font-family:monospace">sparta.checkers.quals.FlowPermission</span>. 
ANY is allowed just as it is in @Source and @Sink. Note that non-sensitive 
data is always allowed to flow to a sensitive sink. This means that
<span style="font-family:monospace">{} -&gt; ANY</span> and <span style="font-family:monospace">ANY -&gt; {}</span> are always allowed and need not be 
written in the flow policy. </p><p>Multiple sinks can appear on the same line if they are separated by commas. 
For example, this policy file:
</p><pre>
   MICROPHONE -&gt; INTERNET, LOG, DISPLAY
</pre><p>
is equivalent to this policy file:
</p><pre>
   MICROPHONE -&gt; INTERNET
   MICROPHONE -&gt; LOG
   MICROPHONE -&gt; DISPLAY, INTERNET
</pre><p>The policy file may contain blank lines and comments that begin with 
a number sign (<span style="font-family:monospace">#</span>) character. <br>
</p><p>Both sources and sinks have optional parameters. These parameters must appear
right after the permission that is being parameterized, grouped in parentheses. 
Each parameter string is be wrapped in quotations, and multiple parameter
strings for a single permission are separated by commas.<br>
</p><p>For example, this policy file:
</p><pre>
   MICROPHONE -&gt; INTERNET("mydomain.org", "goodguys.com", "*.google.com")
</pre><p>
is equivalent to this policy file:
</p><pre>
   MICROPHONE -&gt; INTERNET("mydomain.org")
   MICROPHONE -&gt; INTERNET("goodguys.com")
   MICROPHONE -&gt; INTERNET("*.google.com")
</pre>
<!--TOC subsection id="sec28" Using a flow-policy file-->
<h3 id="sec28" class="subsection">3.4.3&#XA0;&#XA0;Using a flow-policy file</h3><!--SEC END --><p>
To use a flow-policy file when invoking the Information Flow Checker from the
command line, pass it the option:
</p><pre>
-AflowPolicy=<em>mypolicyfile</em>
</pre><p>Or if you are using the <span style="font-family:monospace">check-flow</span> ant target, you can pass the option to ant:
</p><pre>
ant -DflowPolicy=<em>mypolicyfile</em> check-flow
</pre><p>
If the flow policy is named <span style="font-family:monospace">flow-policy</span> and is located the top level app directory, the ant 
target will use it automatically.</p>
<!--TOC section id="sec29" Inference and defaults-->
<h2 id="sec29" class="section">3.5&#XA0;&#XA0;Inference and defaults</h2><!--SEC END --><p>
<a id="sec:system:defaults"></a></p><p>A complete type consists of a <span style="font-family:monospace">@Source</span> qualifier, a <span style="font-family:monospace">@Sink</span> qualifier,
and a Java type. To reduce programmer effort and code clutter, most of the
qualifiers are inferred or defaulted. </p><p>A programmer need not write qualifiers within method bodies,
because such types are inferred by the Information Flow Checker (see Section&#XA0;<a href="#sec%3Atype-inference">3.5.1</a>).
Even for method signatures and
fields, a programmer generally writes either <span style="font-family:monospace">@Source</span> or
<span style="font-family:monospace">@Sink</span>, but not both; see Section&#XA0;<a href="#sec%3Ainfer-from-flow-policy">3.5.2</a> and 
Section&#XA0;<a href="#sec%3Aunannotated-types">3.5.3</a>.</p>
<!--TOC subsection id="sec30" Local variable type inference-->
<h3 id="sec30" class="subsection">3.5.1&#XA0;&#XA0;Local variable type inference</h3><!--SEC END --><p>
<a id="sec:type-inference"></a></p><p>A programmer does not write information flow types within method bodies. Rather, local
variable types are inferred.</p><p>We limit type inference to local variables to ensure that
each method can be type-checked in isolation,
with a guarantee that the entire program is type-safe if each method has
been type-checked. It would be possible to perform a whole-program type
inference, but such an approach would not be modular, would be
heavier-weight, would not deal well with cooperating or communicating
applications, and would provide fewer documentation benefits. </p>
<!--TOC subsection id="sec31" Determining sources from sinks and vice versa-->
<h3 id="sec31" class="subsection">3.5.2&#XA0;&#XA0;Determining sources from sinks and vice versa</h3><!--SEC END --><p>
<a id="sec:infer-from-flow-policy"></a></p><p>If a type contains only a flow source or only a flow sink, the other qualifier is
filled in with the most general one that is consistent
with the policy file.
If the programmer writes 
<span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span>, the Information Flow Checker defaults this to
<span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span> <span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span> where &#X3C9; is the
set of flow sinks that all sources in &#X3B1; can flow to.
Similarly,
<span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span> is defaulted to
<span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span> <span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span> where &#X3B1; is the
set of flow sources allowed to flow to all sinks in &#X3C9;.
Defaults are not applied if the programmer writes both a source and a
sink qualifier.</p><p>For example, suppose the flow policy contains the following:</p><pre class="verbatim">    A -&gt; X,Y
    B -&gt; Y
    C -&gt; Y
</pre><p>Then these pairs are equivalent:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >&#XA0;&#XA0;<span style="font-family:monospace">@Source(</span><span style="font-family:monospace">B,C</span><span style="font-family:monospace">)</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(</span><span style="font-family:monospace">B,C</span><span style="font-family:monospace">) @Sink(Y)</span>&#XA0;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&#XA0;&#XA0;<span style="font-family:monospace">@Sink(Y)</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(</span><span style="font-family:monospace">A,B,C</span><span style="font-family:monospace">) @Sink(Y)</span>
</td></tr>
</table></td></tr>
</table><p>This mechanism is useful because oftentimes a programmer thinks about a
computation in terms of only its sources or only its sinks.
The programmer should not have to consider the rest of the program
that provides context indicating the other end of the flow.</p><p>An example is the <span style="font-family:monospace">File</span> constructor:
a newly-created readable file should be annotated with
<span style="font-family:monospace">@Source(FILESYSTEM)</span>, but there is no possible <span style="font-family:monospace">@Sink</span> annotation
that would be correct for all programs.
Instead, the <span style="font-family:monospace">@Sink</span> annotation is omitted, and
our defaulting mechanism provides the correct value
based on the application&#X2019;s flow policy.</p>
<!--TOC subsection id="sec32" Defaults for unannotated types-->
<h3 id="sec32" class="subsection">3.5.3&#XA0;&#XA0;Defaults for unannotated types</h3><!--SEC END --><p>
<a id="sec:unannotated-types"></a></p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Table 3.2: Default information-flow qualifiers for unannotated types</td></tr>
</table></div>
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td class="hbar" colspan=2></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-weight:bold">Location</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-weight:bold">Default Flow Type</span></td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span>
<span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span>, &#X3C9; is the set of sinks allowed to flow from all sources in &#X3B1; </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(</span>&#X3B1;<span style="font-family:monospace">)</span>
<span style="font-family:monospace">@Sink(</span>&#X3C9;<span style="font-family:monospace">)</span>, &#X3B1; is the set of sources allowed to flow to all sinks in &#X3C9; </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Method parameters</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(ANY) @Sink({})</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Method receivers</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(ANY) @Sink({})</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Return types</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source({}) @Sink(ANY)</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Fields</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source({}) @Sink(ANY)</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">null</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source({}) @Sink(ANY)</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Other literals</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source({}) @Sink(ANY) </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Local variables</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(ANY) @Sink({})</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Upper bounds</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(ANY) @Sink({})</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > Resource variables</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source(ANY) @Sink({})</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > All other locations</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@Source({}) @Sink({})</span></td></tr>
</table><p><a id="tab:defaults"></a>
</p><div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Table <a href="#tab%3Adefaults">3.2</a> shows defaults for completely unannotated types.
The Information Flow Checker allows a developer to choose a different default for a
particular method, class, or package.
When the default is only a source or only a sink, the other qualifier is
inferred from the policy file as explained in
Section&#XA0;<a href="#sec%3Ainfer-from-flow-policy">3.5.2</a>.</p><p>As is standard, the <span style="font-family:monospace">null</span> literal is given the bottom type qualifier, which allows it to be assigned to any variable.
For the Information Flow Checker, the bottom type qualifier is <span style="font-family:monospace">Source(</span><span style="font-family:monospace">{</span><span style="font-family:monospace">}</span><span style="font-family:monospace">)</span>  <span style="font-family:monospace">@Sink(ANY)</span>.</p>
<!--TOC subsection id="sec:additionalanno" Declaration annotations to specify defaulting-->
<h3 id="sec:additionalanno" class="subsection">3.5.4&#XA0;&#XA0;Declaration annotations to specify defaulting</h3><!--SEC END --><p>The Information Flow Checker has additional declaration annotations that are shorthand for common 
annotation patterns on method signatures. They override the usual defaulting of method declarations.</p>
<!--TOC subsubsection id="sec:polyflow" @PolyFlow-->
<h4 id="sec:polyflow" class="subsubsection">@PolyFlow</h4><!--SEC END --><p>Annotation <span style="font-family:monospace">@PolyFlow</span> expresses that each contained method should be annotated as <span style="font-family:monospace">@PolySource</span> 
<span style="font-family:monospace">@PolySink</span> for both the return types and all parameters. It should be used to express a relationship 
between the return type and the parameter types, but not the receiver type</p>
<!--TOC subsubsection id="sec:polyflowreceiver" @PolyFlowReceiver-->
<h4 id="sec:polyflowreceiver" class="subsubsection">@PolyFlowReceiver</h4><!--SEC END --><p>Annotation <span style="font-family:monospace">@PolyFlowReceiver</span> expresses that each contained method should be annotated as <span style="font-family:monospace">@PolySourceR</span> <span style="font-family:monospace">@PolySinkR</span> for the return type, all parameter types, and the receiver type. 
(If the method or constructor does not have a receiver, then the annotation is treated as <span style="font-family:monospace">@PolyFlow</span>.</p>
<!--TOC subsubsection id="sec:declannosstubfiles" Declaration annotations in stub files-->
<h4 id="sec:declannosstubfiles" class="subsubsection">Declaration annotations in stub files</h4><!--SEC END --><p>
If <span style="font-family:monospace">@PolyFlow</span> or <span style="font-family:monospace">@PolyFlowReceiver</span> is written on a class or package, then the annotation applies
to all contained methods or classes unless those classes or methods are annotated with another 
declaration annotation. </p><p>This change of defaulting happens to library methods that are not written in stub files. For example, the class
Integer as been annotated with <span style="font-family:monospace">@PolyFlowReceiver</span>, but the toString method is not listed in the stub file. 
This method is inferred to be annotated with <span style="font-family:monospace">@PolyFlowReceiver</span> and therefore its use will not result in a 
type error involving the <span style="font-family:monospace">NOT_REVIEWED</span> FlowPermission. </p>
<!--TOC subsection id="sec:infer-param-perms" Inferring annotations with parameterized permissions-->
<h3 id="sec:infer-param-perms" class="subsection">3.5.5&#XA0;&#XA0;Inferring annotations with parameterized permissions</h3><!--SEC END --><p>The declaration annotation @InferParameterizedPermission is used to indicate
that a method&#X2019;s return type should use a parameterized permission, where the
parameter of that permission is derived from the value of a method argument.
The annotation indicates which argument(s) and/or receiver should be used,
which permission should be parameterized, whether that permission is a source,
a sink or both, and what if any separator should be used to concatenate
multiple arguments. The value of a method argument is determined using the
Constant Value Checker, which is documented in the Checker Framework Manual.</p><p>For example, </p><pre class="verbatim"> // stub file:
@InferParameterizedPermission(value=FILESYSTEM, param=1, isA=source)
@Source(FILESYSTEM) FileInputStream(String arg0);

 // source code:
@Source("FILESYSTEM(filename)") FileInputStream fis = new FileInputStream("filename");
</pre>
<!--TOC section id="sec:waringsuppression" Warning suppression-->
<h2 id="sec:waringsuppression" class="section">3.6&#XA0;&#XA0;Warning suppression</h2><!--SEC END --><p>Sometimes it might be necessary to suppress warnings or errors produced by
the Information Flow Checker. This can be done by using the
<span style="font-family:monospace">@SuppressWarnings("flow")</span> annotation on a variable, method, or (rarely)
class declaration. Because this annotation can be used to subvert the Flow
Checker, its use is considered suspicious. Anytime a warning or error is
suppressed, you should write a brief comment justifying the suppression.
<span style="font-family:monospace">@SuppressWarnings("flow")</span> should only be used if there is no way to
annotate the code so that an error or warning does not occur. </p>
<!--TOC section id="sec:apispecs" Annotating library API methods in stub files-->
<h2 id="sec:apispecs" class="section">3.7&#XA0;&#XA0;Annotating library API methods in stub files</h2><!--SEC END --><p>Annotations for API methods are found in the stub files in sparta-code/src/sparta/checkers/flowstubfiles.
For details, see Section&#XA0;<a href="#flow-task-annotate-apis">6.3.1</a> of this manual, and also 
chapter
&#X201C;<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries">Annotating
Libraries</a>&#X201D; in the Checker Framework Manual. 
The methods that appear in stub files are defaulted the same way as methods 
written in apps, including flow policy inference. 
(See the defaulting section, Section&#XA0;<a href="#sec%3Asystem%3Adefaults">3.5</a>.) </p><p>Any method, constructor, or field not written in the stub files or found in source code is not defaulted normally. 
Instead, all locations except final fields are default to <span style="font-family:monospace">@Source(ANY) @Sink(ANY)</span>. 
(Final fields are defaulted to <span style="font-family:monospace">@Source({})</span>.)
This way, if such an API method is used, a type error
will occur and alert the user to review and annotate the method. 
A tool, discussed in Section <a href="#flow-task-annotate-apis">6.3.1</a>, issues a warning every time a type declared in a 
library that does not appear in a stub file is used. This tool also outputs a list of declarations missing from
the stub files. </p>
<!--TOC section id="sec:stricter" Stricter tests-->
<h2 id="sec:stricter" class="section">3.8&#XA0;&#XA0;Stricter tests</h2><!--SEC END --><p>By default, the Information Flow Checker is unsound. After getting the basic checks to pass, the
stricter checks should be enabled, by running <span style="font-family:monospace">ant -Dsound=true check-flow</span>.
This two-phase approach was chosen to reduce
the annotation effortand to give two separate phases of
the annotation effort.
The sound checking enforces invariant 
array subtyping and type safety in downcasts.</p><p>When strict checks are turned on,
a cast <span style="font-family:monospace">(Object []) x</span>, were <span style="font-family:monospace">x</span> is of type <span style="font-family:monospace">Object</span>, will result
in a compiler warning:</p><pre>
[jsr308.javac] ... warning: "@Sink @Source(ANY) Object"
       may not be casted to the type "@Sink @Source Object"
</pre><p>The reason is that there is not way for the type-checker to verify
the component type of the array. There is no static knowledge about the actual
runtime values in the array and important flow could be hidden.
The analyst should argue why the downcast is safe.</p><p>Note that the main qualifier of a cast is automatically flow-refined
by the cast expression.</p><p><br>
</p><p>Stricter checking also enforces invariant array subtyping, which is
needed for sound array behavior in the absence of runtime checks.
Flow inference automatically refines the type of array creation
expressions depending on the left-hand side.</p><p><br>
</p><hr>
<!--TOC chapter id="intent-checker" Intent Checker-->
<h1 id="intent-checker" class="chapter">Chapter&#XA0;4&#XA0;&#XA0;Intent Checker</h1><!--SEC END --><p>This chapter describes the Intent Checker,
which type-checks information flows across communicating components of an
Android app.</p><p>Android intents are used for
communication within an app, among apps, and with the Android system.
Intents can be seen as messages exchanged between Android components. Sensitive
data can flow in and out of intent objects. Consequently, to detect forbidden
flows derived from inter-component communication, the Intent Checker needs to
identify the information flow types of the data in an intent.</p><p>To use the Intent Checker, a programmer must supply two types of information:
</p><ul class="itemize"><li class="li-itemize">
Information about inter-component communication across apps for the target
program. Section <a href="#component-map">4.1</a> shows how to compute that
information and supply it to the Intent Checker.
</li><li class="li-itemize">Type qualifiers used to express the data types in an intent. Section
<a href="#intent-types">4.2</a> describes the type qualifiers used by the Intent Checker.
</li></ul><p>Sending an intent is similar to an ordinary method call,
where the data in the intent are the method&#X2019;s arguments. 
The Intent Checker verifies that for any sending intent method
call and its matching receiving intent method declarations,
the intent argument of the caller is compatible with that of the corresponding
callee. </p><p>An Android component can send a message to an Activity by calling the method <span style="font-family:monospace">startActivity</span>, a
Service by calling the method <span style="font-family:monospace">startService</span>, or a BroadcastReceiver by
calling <span style="font-family:monospace">sendBroadcast</span>. Intents are received in an Activity by the method
<span style="font-family:monospace">setIntent</span>, in a Service by the method <span style="font-family:monospace">onBind</span> or
<span style="font-family:monospace">onStartCommand</span>, and in a BroadcastReceiver by the method
<span style="font-family:monospace">onReceive</span>. For simplicity in this manual, we abstract all methods
that send an intent as the method call <span style="font-family:monospace">sendIntent</span>, and all methods that
receive an intent as the method declaration <span style="font-family:monospace">onReceive</span>.</p>
<!--TOC section id="component-map" Inter-component communication-->
<h2 id="component-map" class="section">4.1&#XA0;&#XA0;Inter-component communication</h2><!--SEC END --><p>The <em>component map</em>
of an app contains information regarding how the components of this app
communicate with each other, and how they communicate with components from other
apps. Section <a href="#component-map-generation">6.3.5</a> explains how to generate a
component map file for an app.</p>
<!--TOC subsection id="sec43" Semantics of a component map-->
<h3 id="sec43" class="subsection">4.1.1&#XA0;&#XA0;Semantics of a component map</h3><!--SEC END --><p>
The component map matches <span style="font-family:monospace">sendIntent</span> calls to
declarations of the <span style="font-family:monospace">onReceive</span> methods they implicitly invoke. A <span style="font-family:monospace">sendIntent</span>
call may be paired with more than one <span style="font-family:monospace">onReceive</span> declaration. Each such pair
indicates that the two components, possibly from different apps, may communicate
through intents. The set of pairs of communicating components is conservative,
that is it includes all possible pairs of methods that might communicate.</p>
<!--TOC subsection id="sec44" Syntax of a component map file-->
<h3 id="sec44" class="subsection">4.1.2&#XA0;&#XA0;Syntax of a component map file</h3><!--SEC END --><p>
Each line of a component map file specifies one intent-sending method in the app
and all components in the app that may receive intents that it sends.</p><p>For example, the following line</p><p><span style="font-family:monospace">com.package.ActivityA.foo() -&gt; com.package.ActivityB,
com.package.ActivityC</span> </p><p>indicates that an intent sent in the method <span style="font-family:monospace">foo()</span> from 
<span style="font-family:monospace">ActivityA</span> may be received by the components whose fully-qualified class 
names are <span style="font-family:monospace">com.package.ActivityB</span> and <span style="font-family:monospace">com.package.ActivityC</span>.</p>
<!--TOC subsection id="sec45" Using a component map file-->
<h3 id="sec45" class="subsection">4.1.3&#XA0;&#XA0;Using a component map file</h3><!--SEC END --><p>
It is recommended to name the component map file as <span style="font-family:monospace">component-map</span> and to
put it in the top level app directory. By doing so the ant target will use it
automatically when running:</p><p><span style="font-family:monospace">ant check-intent</span></p><p>Alternatively it is possible to pass the component map file path as an option
to ant:</p><p><span style="font-family:monospace">ant -DcomponentMap=</span><span style="font-family:monospace"><span style="font-style:italic">mycomponentmapfile</span></span><span style="font-family:monospace"> check-intent</span></p>
<!--TOC section id="intent-types" Intent types-->
<h2 id="intent-types" class="section">4.2&#XA0;&#XA0;Intent types</h2><!--SEC END --><p>
An intent contains a map from string keys to arbitrary values. Consider an
intent variable <span style="font-family:monospace">i</span>. Data can be added to the map of <span style="font-family:monospace">i</span> by
the sender component with <span style="font-family:monospace">i.putExtra("key",val)</span> and then retrieved by the
receiver component with <span style="font-family:monospace">i.getExtra("key",default)</span>. An intent type is an
approximation to the keys that may be in the intent object at run time and to
the type of the values that those keys may map to. The type qualifiers used to
represent an intent type are <span style="font-family:monospace">@IntentMap</span> and <span style="font-family:monospace">@Extra</span>.</p>
<!--TOC subsection id="sec47" Syntax-->
<h3 id="sec47" class="subsection">4.2.1&#XA0;&#XA0;Syntax</h3><!--SEC END --><p>
The type qualifier <span style="font-family:monospace">@IntentMap</span> on an intent variable&#X2019;s type indicates the
types of the key/value mappings that are permitted to be accessed via
<span style="font-family:monospace">putExtra</span> and <span style="font-family:monospace">getExtra</span> calls.
An <span style="font-family:monospace">@IntentMap</span> type qualifier contains a set of <span style="font-family:monospace">@Extra</span> type qualifiers. An
<span style="font-family:monospace">@Extra</span> type qualifier contains a key <span style="font-style:italic">k</span>, a source type <span style="font-style:italic">source</span>, and a 
sink type <span style="font-style:italic">sink</span>. This means that the key <span style="font-style:italic">k</span> maps to a value of source type 
<span style="font-style:italic">source</span> and sink type <span style="font-style:italic">sink</span>. Consider the declaration below:</p><pre class="verbatim">@IntentMap({@Extra(key = "k1", source = {FILESYSTEM}, sink = {INTERNET}),
            @Extra(key = "k2", source = {FILESYSTEM}, sink = {DISPLAY})}) 
Intent i = new Intent();
</pre><p>The variable <span style="font-family:monospace">i</span> is annotated with an <span style="font-family:monospace">@IntentMap</span> type containing a set of
two <span style="font-family:monospace">@Extra</span> types, allowing this variable to be accessed via
<span style="font-family:monospace">i.putExtra("k1",...)</span>, <span style="font-family:monospace">i.putExtra("k2",...)</span>, <span style="font-family:monospace">i.getExtra("k1")</span> and
<span style="font-family:monospace">i.getExtra("k2")</span>. No other keys are allowed to be accessed via
<span style="font-family:monospace">putExtra</span> or <span style="font-family:monospace">getExtra</span> calls. </p><p>Each intent variable&#X2019;s type must have only one <span style="font-family:monospace">@IntentMap</span> type qualifier. Two
different <span style="font-family:monospace">@Extra</span> type qualifiers in the same <span style="font-family:monospace">@IntentMap</span> may not have the
same key <span style="font-style:italic">k</span>.</p><p>Every <span style="font-family:monospace">onReceive</span> method has an intent formal parameter.
Below is an example of an annotated intent formal parameter for the <span style="font-family:monospace">onReceive</span>
method <span style="font-family:monospace">setIntent</span>:</p><pre class="verbatim">@Override
public void setIntent(@IntentMap({
        @Extra(key = "location", source = {ACCESS_FINE_LOCATION }, sink = {})
                }) Intent newIntent) {
    super.setIntent(newIntent);
}
</pre>
<!--TOC subsection id="sec48" Semantics-->
<h3 id="sec48" class="subsection">4.2.2&#XA0;&#XA0;Semantics</h3><!--SEC END --><p>
If variable <span style="font-family:monospace">i</span> is declared to have an intent type <span style="font-style:italic">T</span>, then two facts must be
true. (1) For any key <span style="font-family:monospace">k</span> that is accessed at run time in <span style="font-family:monospace">i</span>, it must be
listed in <span style="font-style:italic">T</span>. That is, the keys of <span style="font-family:monospace">i</span> that are accessed are
a subset of <span style="font-style:italic">T</span>&#X2019;s keys. It is
permitted for the run-time value of variable <span style="font-family:monospace">i</span> to have fewer keys than those
listed by its type. It is also permitted for the run-time value of variable
<span style="font-family:monospace">i</span> to have more keys than those listed by its type but they may not be
accessed. (2) For any key <span style="font-style:italic">k</span> that is a key in the run-time value of <span style="font-family:monospace">i</span>,
the value mapped by <span style="font-style:italic">k</span> in the value has type mapped by <span style="font-style:italic">k</span> in <span style="font-style:italic">T</span>. 
This can be more concisely expressed as &#X2200; <span style="font-style:italic">k</span>.<span style="font-style:italic">i</span>[<span style="font-style:italic">k</span>] &lt;: <span style="font-style:italic">T</span>[<span style="font-style:italic">k</span>]. As permitted
by object-oriented typing, the run-time class of <span style="font-family:monospace">i[</span><span style="font-style:italic">k</span><span style="font-family:monospace">]</span> may be a subtype of <span style="font-style:italic">T</span>.</p><p>As an example, consider the declarations and method calls below:</p><pre class="verbatim">@IntentMap({@Extra(key = "picture", source = {FILESYSTEM}, sink = {INTERNET}),
            @Extra(key = "location", source = {FILESYSTEM}, sink = {DISPLAY})}) 
Intent i = new Intent();

@Source(FILESYSTEM) @Sink(INTERNET) File getPicture() {...}
@Source(ACCESS_FINE_LOCATION) @Sink(INTERNET) String getLocation() {...}

void fillIntent() {
    i.putExtra("picture", getPicture());        // Legal.
    i.putExtra("someRandomKey", getPicture());  // Violates requirement (1).
    i.putExtra("location", getLocation());      // Violates requirement (2).
    ...
}

void processDataFromIntent() {
    // pic will have source type FILESYSTEM and sink type INTERNET.
    File pic = i.getExtra("picture", null);               // Legal.
    // loc will have source type FILESYSTEM and sink type DISPLAY.
    String loc = i.getStringExtra("location", null);      // Legal.
    Object randomObject = i.getExtra("someRandomKey");    // Violates requirement (1)
    ...
}
</pre><p>The type of variable <span style="font-family:monospace">i</span> indicates that this object may contain up to two
elements in its map which can be accessed, one with key <span style="font-family:monospace">"picture"</span>,
source type <span style="font-family:monospace">FILESYSTEM</span>, and sink type
<span style="font-family:monospace">INTERNET</span>, and another with key <span style="font-family:monospace">"location"</span>, source type <span style="font-family:monospace">FILESYSTEM</span>, and sink
type <span style="font-family:monospace">DISPLAY</span>. This object may contain more elements but they cannot be
accessed. The method calls in the method <span style="font-family:monospace">fillIntent</span> shows that it is only
valid to invoke putExtra if the value passed as argument is a subtype of the
declared type for the corresponding key. In the method <span style="font-family:monospace">processDataFromIntent</span>,
the variables <span style="font-family:monospace">pic</span> and <span style="font-family:monospace">loc</span> will have their source and sink types
inferred from the type of <span style="font-family:monospace">i</span>. Trying to access key <span style="font-family:monospace">"someRandomKey"</span> violates
requirement (1).</p>
<!--TOC subsubsection id="sec49" Subtyping-->
<h4 id="sec49" class="subsubsection">Subtyping</h4><!--SEC END --><p>
Intent type <span style="font-style:italic">T</span><span style="font-style:italic">1</span> is a subtype of intent type <span style="font-style:italic">T</span><span style="font-style:italic">2</span> if the key set of 
<span style="font-style:italic">T</span><span style="font-style:italic">2</span> is a subset of the key set of <span style="font-style:italic">T</span><span style="font-style:italic">1</span> and, for each key <span style="font-style:italic">k</span> in both 
<span style="font-style:italic">T</span><span style="font-style:italic">1</span> and <span style="font-style:italic">T</span><span style="font-style:italic">2</span>, <span style="font-style:italic">k</span> is mapped to the exact same type, that is, 
<span style="font-style:italic">T</span><span style="font-style:italic">1[</span><span style="font-style:italic">k</span><span style="font-style:italic">]</span> = <span style="font-style:italic">T</span><span style="font-style:italic">2[</span><span style="font-style:italic">k</span><span style="font-style:italic">]</span>.</p>
<!--TOC subsubsection id="sec50" sendIntent calls and copyable rule-->
<h4 id="sec50" class="subsubsection">sendIntent calls and copyable rule</h4><!--SEC END --><p>
A <span style="font-family:monospace">sendIntent</span> call can be viewed as an invocation of one or more <span style="font-family:monospace">onReceive</span> methods.
A <span style="font-family:monospace">sendIntent</span> call type-checks if its intent argument is
copyable to the formal parameter of each corresponding <span style="font-family:monospace">onReceive</span> methods.
Copyable is a subtyping-like relationship with the weaker requirement: 
<span style="font-family:monospace">T1[k]</span> &lt;: <span style="font-family:monospace">T2[k]</span> instead of <span style="font-family:monospace">T1[k]</span> = <span style="font-family:monospace">T2[k]</span>.
This is sound because the Android system passes a copy of the intent argument to
<span style="font-family:monospace">onReceive</span>, so aliasing is not a concern.</p>
<!--TOC subsubsection id="override-onreceive" Overriding and calling onReceive methods-->
<h4 id="override-onreceive" class="subsubsection">Overriding and calling onReceive methods</h4><!--SEC END --><p>
Every <span style="font-family:monospace">onReceive</span> method has a parameter of type <span style="font-family:monospace">Intent</span>, and this
parameter must be annotated with <span style="font-family:monospace">@IntentMap</span> and <span style="font-family:monospace">@Extra</span>.</p><p>The normal Java overriding rules do not apply to declarations of <span style="font-family:monospace">onReceive</span>. The
type of the formal parameter of <span style="font-family:monospace">onReceive</span> is not restricted by the type of the
parameter in the overridden declaration. This is allowable because by convention
<span style="font-family:monospace">onReceive</span> is never called directly but rather is only called by the Android
system via a <span style="font-family:monospace">sendIntent</span> method call. The Intent Checker prohibits direct
calls to <span style="font-family:monospace">onReceive</span> methods.</p><p>There is a peculiarity for the <span style="font-family:monospace">onReceive</span> method in Activities, <span style="font-family:monospace">setIntent</span>.
Every Activity that calls the method <span style="font-family:monospace">getIntent</span> must override both methods
<span style="font-family:monospace">setIntent</span> and <span style="font-family:monospace">getIntent</span>. The return type of <span style="font-family:monospace">getIntent</span> must be annotated
with the same type as the formal parameter of <span style="font-family:monospace">setIntent</span>, so that when the
method <span style="font-family:monospace">getIntent</span> is called the correct type is returned.</p><hr>
<!--TOC chapter id="analyze-annotated-app" How to Analyze an Annotated App-->
<h1 id="analyze-annotated-app" class="chapter">Chapter&#XA0;5&#XA0;&#XA0;How to Analyze an Annotated App</h1><!--SEC END --><p>If you are presented with an annotated app, you can confirm the work of the
person who did the annotation by answering affirmatively three questions.</p><ol class="enumerate" type=1><li class="li-enumerate">
Does the flow-policy file match the application description?
</li><li class="li-enumerate">Does the Information Flow Checker produce any errors or warnings?
</li><li class="li-enumerate">Does the justification for each <span style="font-family:monospace">@SuppressWarnings</span> make sense?
</li></ol>
<!--TOC section id="sec53" Review the flow policy-->
<h2 id="sec53" class="section">5.1&#XA0;&#XA0;Review the flow policy</h2><!--SEC END --><p>
Does the flow-policy file match the application description? There should
not be any flows that are not explained in the description. These flows
may be explicitly stated, such as &#X201C;encrypt and sign messages, send them
via your preferred email app.&#X201D; Or a flow may only be implied, such as
&#X201C;This Application allows the user to share pics with their contacts.&#X201D; In
the first example, you would expect an EMAIL sink to appear somewhere in
the policy file. In the second, &#X201C;share&#X201D; could mean a you would see a Flow
Sink of EMAIL, SMS, INTERNET, or something else. Flows that are only
implied in the description could be grounds for rejection if the
description is too vague.</p>
<!--TOC section id="sec54" Run the Information Flow Checker-->
<h2 id="sec54" class="section">5.2&#XA0;&#XA0;Run the Information Flow Checker</h2><!--SEC END --><p>Run the Information Flow Checker (Chapter&#XA0;<a href="#flow-checker">3</a>) to ensure that there is no
data flow in the application beyond what is expressed in the given flow
policy:</p><pre>
ant -DflowPolicy=myflowpolicy check-flow
</pre><p>If the Information Flow Checker produces any errors or warnings, then the app has not
been properly annotated and should be rejected.</p>
<!--TOC section id="sec55" Review <span style="font-family:monospace">@SuppressWarnings</span> justifications-->
<h2 id="sec55" class="section">5.3&#XA0;&#XA0;Review <span style="font-family:monospace">@SuppressWarnings</span> justifications</h2><!--SEC END --><p>
Does the justification for every <span style="font-family:monospace">@SuppressWarnings</span> make sense? Search
for every instance of <span style="font-family:monospace">@SuppressWarnings("flow")</span> and read the
justification comment. Compare the justification to the actual code and
determine if it make sense and should be allowed. If some <span style="font-family:monospace">@SuppressWarnings</span> has
no justification comment, that is for rejection.</p><hr>
<!--TOC chapter id="analyze-unannotated-app" How to Analyze an Unannotated App-->
<h1 id="analyze-unannotated-app" class="chapter">Chapter&#XA0;6&#XA0;&#XA0;How to Analyze an Unannotated App</h1><!--SEC END --><p>If you are presented with an unannotated app and wish to confirm that it
contains no malware, then you need to perform three tasks:
</p><ul class="itemize"><li class="li-itemize">
Look for obvious malware.
</li><li class="li-itemize">Run reverse-engineering tools to understand the application.
</li><li class="li-itemize">Write and check information-flow type qualifiers to ensure that the
program has no undesired information flow.
</li></ul><p>More specifically, the recommended workflow is:</p><ol class="enumerate" type=1><li class="li-enumerate">
Set up the app for analysis by the SPARTA tools; see Section&#XA0;<a href="#sec%3Aantsetup">2.3</a>
</li><li class="li-enumerate">Write the flow policy; see Section&#XA0;<a href="#sec%3Awrite-flow-policy">6.1</a>
</li><li class="li-enumerate">Run reverse-engineering tools; see Section&#XA0;<a href="#sec%3Areverse-engineering">6.2</a>
</li><li class="li-enumerate">Write and check information flow type qualifiers; see Section&#XA0;<a href="#verify-information-flow-security">6.3</a>
</li></ol>
<!--TOC section id="sec:write-flow-policy" Write a flow-policy file-->
<h2 id="sec:write-flow-policy" class="section">6.1&#XA0;&#XA0;Write a flow-policy file</h2><!--SEC END --><p>Write a flow-policy file. Section&#XA0;<a href="#sec%3Aflow-policy">3.4</a> describes flow policies.</p>
<!--TOC subsection id="sec58" Read the app description-->
<h3 id="sec58" class="subsection">6.1.1&#XA0;&#XA0;Read the app description</h3><!--SEC END --><p>
<a id="sec:read-the-app-description"></a></p><p>Read the App description and user documentation, looking for clues about
the permissions, sensitive sources, and sinks and how information
flows between them. For example,
if this is a map app, does the description say anything about sending your location data over the
network? If so, then you should add <span style="font-family:monospace">LOCATION</span>&#X2192;<span style="font-family:monospace">INTERNET</span> to the flow-policy file. Where
else does the description say location data can go? </p><p>Theoretically, you should be able to write a complete Flow Policy from the
description if the description is well-written and the app does not contain
malware. In practice, you will have to add flows to the policy file as you
more fully annotate the app, but you should ensure that they are reasonable
and make note of what additional flows you had to add.</p>
<!--TOC subsection id="sec59" Read the manifest file-->
<h3 id="sec59" class="subsection">6.1.2&#XA0;&#XA0;Read the manifest file</h3><!--SEC END --><p>Look at the <span style="font-family:monospace">AndroidManifest.xml</span> file and:
</p><ul class="itemize"><li class="li-itemize">
Determine which permissions the app uses &#X2014; the &#X201C;uses-permission&#X201D;
entries in the manifest file.<p>(If you are short on time, you could start with reading the manifest file
rather than first reading the app description as recommended in
Section&#XA0;<a href="#sec%3Aread-the-app-description">6.1.1</a>. But determining the permissions
from the documentation will be more effective in finding problems in
either the documentation or the code.)
</p></li><li class="li-itemize">Compare the used permissions with the description of the
application and determine whether or not they are well justified.
If an application uses certain permissions that are not justified
in the description, this indicates suspicious code. 
(To determine where these permissions are used in the application,
see <a href="#sec%3Aappanalysis%2Freport-permissions">6.2.3</a>)</li><li class="li-itemize">Determine the entry points into the source code. (This may also give
a hint about the architecture or overall modular structure of the
application.)
Look for &#X201C;activity&#X201D;, &#X201C;intent-filter&#X201D;, &#X201C;service&#X201D;, &#X201C;receiver&#X201D;, and
&#X201C;provider&#X201D; to see the entry points, intent messages it responds to,
etc.</li></ul>
<!--TOC section id="sec:reverse-engineering" Run reverse-engineering tools-->
<h2 id="sec:reverse-engineering" class="section">6.2&#XA0;&#XA0;Run reverse-engineering tools</h2><!--SEC END -->
<!--TOC subsection id="sec61" Review constant strings used-->
<h3 id="sec61" class="subsection">6.2.1&#XA0;&#XA0;Review constant strings used</h3><!--SEC END --><p>
<a id="sec:appanalysis/strings"></a></p><p>Run</p><pre class="verbatim">  ant report-strings
</pre><p>to get a list of all constant strings used in the the program grouped by
category. A file, <span style="font-family:monospace">found-strings.txt</span> in the <span style="font-family:monospace">sparta-out</span> directory, lists a
summary of all strings used in the app grouped by category. Categories are
URLs, content URIs, class names, file or path names, SQL statements, messages
to the user, and no category. Each string is only assigned to one category.
This ant target also reports where in the code the string was found. For
example,</p><pre class="verbatim">.../MapActivity.java:41: warning: [found.url] 
   intent.setData(Uri.parse("http://darknessmap.com"));
                           ^
   Possible URL string: http://darknessmap.com 
</pre><p>shows where a URL string is found in the found. </p>
<!--TOC subsection id="sec62" Review suspicious code and API uses-->
<h3 id="sec62" class="subsection">6.2.2&#XA0;&#XA0;Review suspicious code and API uses</h3><!--SEC END --><p>
<a id="sec:appanalysis/suspicious"></a></p><p>Run</p><pre class="verbatim">  ant report-suspicious
</pre><p>to get a list of the most suspicious code
locations. 
The code may be innocuous, but a human should examine it.</p><p>This target reports
</p><ul class="itemize"><li class="li-itemize">
uses of potentially dangerous APIs, including reflection, randomness,
thread spawning, and the ACTION VIEW intent.<p>The file <span style="font-family:monospace">sparta-code/src/sparta/checkers/suspicious.astub</span> contains the classes and methods that are considered suspicious.</p><p>The following example from the <span style="font-family:monospace">suspicious.astub</span> file reports all calls
of the <code>invoke</code> method and, additionally, all constructor calls 
of the class <code>java.util.Random</code>:</p><pre class="verbatim">package java.lang.reflect;                                             
class Method {                                                         
    @ReportCall                                                        
    public Object invoke(Object obj, Object [] objs) {}                
}                                                                      
                                                                       
package java.util;                                                     
@ReportCreation                                                        
class Random {}
</pre></li><li class="li-itemize">suspicious String patterns (e.g., hard-coded URIs and IP and MAC addresses) 
in <code>.java</code> and <code>strings.xml</code> files. The searched-for patterns
appear in the script <span style="font-family:monospace">sparta-code/suspicious.pl</span>.</li></ul><p>If you learn of additional suspicious API uses or String patterns, please
inform the SPARTA developers so they can add them to the
<span style="font-family:monospace">suspicious.astub</span> or <span style="font-family:monospace">suspicious.pl</span> file.</p>
<!--TOC subsection id="sec63" Review where permissions are used in the application-->
<h3 id="sec63" class="subsection">6.2.3&#XA0;&#XA0;Review where permissions are used in the application</h3><!--SEC END --><p>
<a id="sec:appanalysis/report-permissions"></a></p><p>Run</p><pre class="verbatim">  ant report-permissions
</pre><p>to see where the application calls API methods that may require some Android permissions. 
The <span style="font-family:monospace">ant report-permissions</span> tool will help you gain an understanding of how your
app first obtains information from a sensitive source, or how your app
finally sends information to a sensitive sink. This may help you decide
what parts of the app to further investigate, or where to start your
annotation work.</p><p>There are three possible types of errors you will see. The first error:</p><pre class="verbatim">MainActivity.java:35: 
error: Call require permission(s) [android.permission.SET_WALLPAPER], 
but caller only provides []!
   clearWallpaper();
                 ^
</pre><p>This error means the method requires one or more permissions which the caller does not have.
The second error:</p><pre class="verbatim">MediaPlayerActivity.java:218:
error: Call may additionally require permission(s) 
[android.Manifest.permission.WAKE_LOCK], but caller only provides []! 
Notes: WAKE_LOCK is required if MediaPlayer.setWakeMode has been called first.
             stop();
                 ^
</pre><p>This error means the method may or may not require one or more permissions which the caller
does not have. An explanation for the current error can be seen on the <span style="font-family:monospace">Notes</span>. </p><pre class="verbatim">HelloWorldActivity.java:83: warning: If the constant DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED 
is passed to an intent it will require following permission(s): [android.permission.BIND_DEVICE_ADMIN]! 
i.setAction(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED);
            ^
</pre><p>This error means that the constant used depends on one or more permissions.</p><p>You can eliminate the first 2 errors by writing
<span style="font-family:monospace">@RequiredPermissions(</span><span style="font-family:monospace">android.Manifest.permission.</span><span style="font-family:monospace"><em>PERMISSION</em></span><span style="font-family:monospace">)</span> or
<span style="font-family:monospace">@MayRequiredPermissions(</span><span style="font-family:monospace">android.Manifest.permission.</span><span style="font-family:monospace"><em>WAKE_LOCK</em></span><span style="font-family:monospace">)</span> in
front of the method header in the source code, if you would like to propagate the
required permission up the call stack. 
You should use 
<span style="font-family:monospace">@MayRequiredPermissions( value=</span><span style="font-family:monospace">android.Manifest.permission.</span><span style="font-family:monospace"><em>PERMISSION</em></span><span style="font-family:monospace">,
notes=java.lang.String)</span> in case the permission may be required and you should 
explain the reason on the <span style="font-family:monospace">notes</span> argument.
However, it is not necessary to eliminate all the errors from RequiredPermissions. 
The <span style="font-family:monospace">report-permissions</span> tool is only a tool to guide your annotation and manual analysis effort. </p><p>Any permission that is required should already be listed in the
<span style="font-family:monospace">AndroidManifest.xml</span> file.</p><p>The permissions required by the Android API appear in file
<span style="font-family:monospace">src/sparta/checkers/permission.astub</span>, expressed as
<span style="font-family:monospace">@RequiredPermissions</span> and <span style="font-family:monospace">@MayRequiredPermissions</span> annotations.</p>
<!--TOC section id="verify-information-flow-security" Verify information flow security-->
<h2 id="verify-information-flow-security" class="section">6.3&#XA0;&#XA0;Verify information flow security</h2><!--SEC END --><p>When the goal is to completely annotate an application it is
most effective to write information flow annotations in a bottom up approach:
first annotate libraries your code uses, then your packages and classes
that use those libraries, and so forth up to the entry points of your application.
Alternatively, when the goal is to investigate specific information flows, it is
more effective to trace and annotate only the flows of interest.
Libraries should still be annotated first for all flows types.
A bottom up approach can be used as a first pass to annotate large portions of an
application while tracing can be then used to find and fix remaining Information Flow Checker warnings.
Both approaches use the flow-policy create in Section&#XA0;<a href="#sec%3Awrite-flow-policy">6.1</a>.</p><p>Section&#XA0;<a href="#flow-task-annotate-apis">6.3.1</a> describes how to annotate libraries,
Section&#XA0;<a href="#flow-task-annotate-app">6.3.2</a> and Section&#XA0;<a href="#sec%3Arun-type-checker">6.3.3</a> describe how to
annotate your own code in a bottom up approach, and Section&#XA0;<a href="#sec%3Atrace-types">6.3.6</a> describes
how to iteratively trace sensitive sources in your application.</p>
<!--TOC subsection id="flow-task-annotate-apis" Write information flow types for library APIs-->
<h3 id="flow-task-annotate-apis" class="subsection">6.3.1&#XA0;&#XA0;Write information flow types for library APIs</h3><!--SEC END --><p>When the Information Flow Checker type-checks your code that calls a library API, the
Information Flow Checker needs to know the effect of that call. 
Stub files in <span style="font-family:monospace">sparta-code/src/sparta/checkers/flowstubfiles/</span> provide
that information. You may need to enhance those stub files, if they do not
yet contain information about the library APIs that your application uses.
(Over time, the stub files will become more complete, and you will have to
do less work in this step for each new app.)</p><p>Run <span style="font-family:monospace">ant report-not-reviewed</span> to create the <span style="font-family:monospace">missingAPI.astub</span> file. For each method in the 
file do the following. 
</p><ul class="itemize"><li class="li-itemize">
Read the Javadoc.
</li><li class="li-itemize">Decide what flow properties the method has. Take care with this step,
because your decision will be trusted, not checked. If you make a mistake,
the Information Flow Checker&#X2019;s results will not be sound.
</li><li class="li-itemize">Add the method to the stub file that corresponds to the class package, with
appropriate flow properties expressed as <span style="font-family:monospace">@Source(...)</span> and
<span style="font-family:monospace">@Sink(...)</span> annotations.
It would be unusual for an API method to contain both a <span style="font-family:monospace">@Source</span>
and a <span style="font-family:monospace">@Sink</span> annotation.<p>If the method does is not directly related to information flow (its inputs
and outputs could be anything and are not required to have a specific
<span style="font-family:monospace">@Source</span> annotation), then either added the method to the stub file with no 
annotations or to annotate it with <span style="font-family:monospace">@PolyFlow</span> or <span style="font-family:monospace">@PolyFlowReceiver</span>, 
which essentially says that the
output can have all the flow sources and sinks of the inputs.
(See Section Section&#XA0;<a href="#sec%3Aadditionalanno">3.5.4</a> for more details.)</p></li></ul><p><span style="font-weight:bold">Important:</span>
After changing or adding stub files, run <span style="font-family:monospace">ant jar</span> to rebuild <span style="font-family:monospace">sparta.jar</span>.</p><p>The stub files can include any third-party library that is not compiled
along with your application. You can add a new <span style="font-family:monospace">.astub</span> file to the
<span style="font-family:monospace">flowstubfiles/</span> directory. When creating a new stub file, see the section
&#X201C;<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#stub-creating">Creating
a stub file</a>&#X201D; in the Checker Framework Manual to learn how to create an
initial file and prevent a great deal of repetitive cut-and-paste editing.</p><p>Alternately, you can put a new <span style="font-family:monospace">.astub</span> file elsewhere and then pass this
file to the <span style="font-family:monospace">ant check-flow</span> target:</p><pre>
ant -Dstubs=<em>path/myAnnoLib.astub</em> check-flow
</pre><p>Here is an example from a stub file:</p><pre class="verbatim">package android.telephony;

class TelephonyManager {
    public @Source(READ_PHONE_STATE) String getLine1Number();
    public @Source(READ_PHONE_STATE) String getDeviceId();
}
</pre><p>The above annotates two methods in class <span style="font-family:monospace">TelephonyManager</span>.
It indicates that the <span style="font-family:monospace">getLine1Number</span> function returns a String that is a
phone number. For more examples, look into the stub files. Also, see 
the
&#X201C;<a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#annotating-libraries">Annotating
Libraries</a>&#X201D; chapter in the Checker Framework Manual.</p><p>It is usually a good idea to annotate an entire API class at a time, rather
than to just annotate the specific methods that your app uses. Annotating
an entire class lets you think about it once, which takes less time in the
long run. </p><p>Note: at the end of this step, you have not yet added any annotations to
the app itself, only to libraries.</p>
<!--TOC subsection id="flow-task-annotate-app" Infer information flow types for the app-->
<h3 id="flow-task-annotate-app" class="subsection">6.3.2&#XA0;&#XA0;Infer information flow types for the app</h3><!--SEC END --><p>
Use whole program inference to infer annotations for method signatures and fields. 
These inferred 
annotations are written back into source code for use in type checking. In order to use whole program
inference, you first must download an install the inference framework. To do so, clone the repository 
and update to the correct revision using the following commands,
</p><pre class="verbatim">git clone  https://github.com/typetools/checker-framework-inference.git
</pre><p>then follow the instructions in README.sparta to install.</p><p>Run inference to annotate an app:</p><pre class="verbatim">  ant infer
</pre><p>The inference framework is not complete, for example, it does not correctly infer annotations 
for generic types, so you will need to correct annotations. The inference framework will
not change annotations that already appear in source code, so you may wish to remove the inferred 
annotations, add some manual annotations, and then re-run inference. </p>
<!--TOC subsection id="sec:run-type-checker" Type-check the information flow types in the application-->
<h3 id="sec:run-type-checker" class="subsection">6.3.3&#XA0;&#XA0;Type-check the information flow types in the application</h3><!--SEC END --><p>Run the Information Flow Checker:</p><pre class="verbatim">  ant check-flow
</pre><p>Eliminate each warning in one of two ways.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Add annotations to method signatures and fields in the application, as
required by the type-checker. This essentially propagates the flow
information required by the APIs through the application.</li><li class="li-enumerate">Use <span style="font-family:monospace">@SuppressWarnings</span> to indicate safe uses that are safe for reasons
that are beyond the capabilities of the type system. Always write a
comment that justifies that the code is safe, and why the type system
cannot recognize that fact.</li></ol><p>Review the found forbidden flows in <span style="font-family:monospace">sparta-out/forbiddenFlows.txt</span>. 
Flows found in the app but not list in the flow policy will appear in this file. 
You may wish to add these flows to the policy.</p><p>For easier to read warning messages, use the <span style="font-family:monospace">check-flow-pp</span> ant target.</p><p>After you have corrected some of the errors, re-run <span style="font-family:monospace">ant check-flow</span>.
Repeat the process until there are no more errors, or until you find bad
code (malicious, or buggy and prone to abuse).</p>
<!--TOC subsection id="sec68" Check for implicit information flow via conditionals-->
<h3 id="sec68" class="subsection">6.3.4&#XA0;&#XA0;Check for implicit information flow via conditionals</h3><!--SEC END --><p>
Because the then clause of a conditional only executes if the predicate is true, a write
to a sink in the then clause may leak that the predicate evaluated to true. If the predicate
contains information from a sensitive source, then the body of a conditional may leak some 
fact about the sensitive source. This possible information flow is considered implicit.</p><p>Run the conditional checker, after the flow checker reports no more warnings.</p><pre class="verbatim">  ant check-conditionals 
</pre><p>This ant target outputs a warning in every location a sensitive sources is used in a 
predicate. For each warning, you should manually verify that the source is not
implicitly leaked to some sink.</p>
<!--TOC subsection id="sec69" Type-check information flow types across communicating components-->
<h3 id="sec69" class="subsection">6.3.5&#XA0;&#XA0;Type-check information flow types across communicating components</h3><!--SEC END --><p>
This section explains how to generate a component map file for an app, how to
run the Intent Checker for this app, and how to identify which of the raised
warnings are false warnings.</p>
<!--TOC subsubsection id="component-map-generation" Component map file generation-->
<h4 id="component-map-generation" class="subsubsection">Component map file generation</h4><!--SEC END --><p>
The component map contains information about inter-component communication of
an app. To type-check information flow types across communicating components of
an app, a component map file must be generated for that app. The steps to
generate a component map file are:</p><ol class="enumerate" type=1><li class="li-enumerate">Run the <span style="font-family:monospace">generate-cm</span> script, located in the <span style="font-family:monospace">sparta-code</span> folder. This
script receives as argument the path of the target app&#X2019;s root folder,
followed by a set of .apk files of apps that might communicate with the target
app. It is not necessary to pass the .apk of built-in Android apps as arguments.
Below is an example running the script from the <span style="font-family:monospace">sparta-code</span> folder:
<br>
<br>
<pre>
./generate-cm <span style="font-style:italic">target_app&#X2019;s_root_folder</span> <span style="font-style:italic">[app1.apk app2.apk ... appN.apk]</span>
</pre><p><br>
<br>
</p><p>Example of a generated component map file:
<br>
<br>
</p><pre>
com.VideoActivity.onOptionsItemSelected(MenuItem) -&gt; com.VideoActivity.PictureActivity
com.VideoActivity.GCMRegistrar.internalRegister(String) -&gt; com.gtalkservice.PushMessage

#Broadcast Receivers:
#Inspect the method com.VideoActivity.AboutUs.onDestroy(Bundle)
#and replace the "BroadcastReceiver registed in..." text below by
#the fully-qualified name of the BroadcastReceiver registered in
#that location. 
#Also, remove the "Update Line: " prefix.

Update line: com.VideoActivity.AboutUs.onDestroy(Bundle) -&gt; BroadcastReceiver 
                     registered in com.VideoActivity.DisplayService.onBind(Intent)

#Intents assigned at run time:
#Inspect the method com.VideoActivity.AboutUs.onCreate(android.os.Bundle)
#and replace the RUN_TIME_ASSIGNED text below by 
#the fully-qualified names of the components that might 
#receive an intent sent from com.VideoActivity.AboutUs.onCreate(android.os.Bundle). 
#Also, remove the "Update Line: " prefix.

Update line: com.VideoActivity.AboutUs.onCreate(android.os.Bundle) -&gt; RUN_TIME_ASSIGNED

#Intents using URIs:
com.VideoActivity.DisplayService$3.run() -&gt; com.VideoActivity.MyBringBack
com.VideoActivity.DisplayService$3.run() -&gt; com.VideoActivity.SoundListActivity

#No receiver found for these intents:
com.VideoActivity.AboutUs.onPause(Bundle) -&gt; RECEIVER_NOT_FOUND
</pre><p><br>
<br>
</p></li><li class="li-enumerate">After the component map file is generated you may need to refine it if
receiver components could not be resolved in some cases. To check if your
<span style="font-family:monospace">component-map</span> needs a refinement, open it and look for lines starting with:<pre>
Update line:
</pre><p>
<br>
<br>
If the component map has at
least one occurrence of <span style="font-family:monospace">Update line:</span>, it must be refined.
The component map is divided into comment sections. Below is
explained each comment section, and how to update each line when necessary.</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">#Broadcast Receivers:</span> BroadcastReceivers can be dynamically registered to
receive intents. The generated component map shows a method <span style="font-family:monospace">m</span> where a
BroadcastReceiver is registered. The user must manually inspect <span style="font-family:monospace">m</span> and replace
<span style="font-family:monospace">"BroadcastReceiver registered in m"</span> in the component map file by the
fully-qualified names of the BroadcastReceivers
registered in that method. The example above suggests that the user must inspect
the method <span style="font-family:monospace">onBind(Intent)</span> from the class <span style="font-family:monospace">DisplayService</span>, and replace
<span style="font-family:monospace">"BroadcastReceiver registered in
com.VideoActivity.DisplayService.onBind(Intent)"</span> by the fully-qualified names of
the BroadcastReceivers registered in that method.</li><li class="li-itemize"><span style="font-family:monospace">#Intents assigned at run time:</span> The receiver component for this intent is
assigned at run time and could not be statically resolved. A manual inspection
is needed to update these cases. In the example above the <span style="font-family:monospace">onCreate(Bundle)</span>
method of the class <span style="font-family:monospace">AboutUs</span> must be inspected to find out the receiver
components of this intent. The <span style="font-family:monospace">RUN_TIME_ASSIGNED</span> string in this line
should be replaced by the fully-qualified names of the receiver components
assigned at run time.</li><li class="li-itemize"><span style="font-family:monospace">#Intents using URIs:</span> The component map generation does not differentiate
intent filters with the same action and categories but different data (URI).
You must manually inspect the intent-sending method and discover the receiver
components. Every communication that uses URIs will be shown in the component
map file so that the you can comment the ones you are certain that are not
receiving an intent from that intent-sending method.</li><li class="li-itemize"><span style="font-family:monospace">#No receiver found for these intents:</span> There are no receiver components for
these intent-sending methods in the set of apps provided in the component map
generation.
</li></ul></li></ol>
<!--TOC subsubsection id="sec71" Annotating components from other applications-->
<h4 id="sec71" class="subsubsection">Annotating components from other applications</h4><!--SEC END --><p>
In case the app being analyzed communicates with components from
other apps, these components need to be correctly annotated and you need to add
their .java files in the <span style="font-family:monospace">sparta-code/annotated-intent-receivers</span>, or in the
target app&#X2019;s source code directory. You should stick with the first option if the
component you are adding is an Android system component, so it can be used in
future analyses.</p>
<!--TOC subsubsection id="sec72" Running the Intent Checker with the Information Flow Checker-->
<h4 id="sec72" class="subsubsection">Running the Intent Checker with the Information Flow Checker</h4><!--SEC END --><p>The Intent Checker type-checks information flow types across communicating
components and within components. To run the Intent Checker with
the Information Flow Checker from the command line use the command <span style="font-family:monospace">check-intent</span> instead
of <span style="font-family:monospace">check-flow</span>:</p><pre>
    ant [-DflowPolicy=<span style="font-style:italic">myflowpolicyfile</span>] [-DcomponentMap=<span style="font-style:italic">mycomponentmapfile</span>] check-intent
</pre>
<!--TOC subsubsection id="sec73" Common warnings and errors in the Intent Checker-->
<h4 id="sec73" class="subsubsection">Common warnings and errors in the Intent Checker</h4><!--SEC END --><p>Error: intent.receiver.notfound:</p><pre class="verbatim">tests/intent/ActivityTest.java:118: error: [intent.receiver.notfound]
            startActivity(i);
                          ^
Could not find receivers for the intent sent in method:
tests.ActivityTest.receiverNotFound(). Regenerate the component map file or add
a line in it from this method to one or more receiver components of that intent.

</pre><p>This error occurs when type-checking a <span style="font-family:monospace">sendIntent</span> call whose method in which
it is called is not in the component map file. This happens when the component
map file wasn&#X2019;t correctly generated or when it is necessary to do a manual
inspection to add the correct receivers of an intent.</p><p>To solve this error, regenerate the component map file. If the error
persists you need to manually inspect the method stated in the error message,
look for intents sent in that method, identify the receiver components, and add
add an entry in the component map file from this method to the receiver
components. For example:</p><pre class="verbatim">com.package.ActivityA.foo() -&gt; com.package.ActivityB
or
com.package.ActivityA.foo() -&gt; RECEIVER_NOT_FOUND
</pre><p>Use the later if the intent is not being received by any component.</p><p><br>
<br>
Warning: send.intent.missing.key:</p><pre class="verbatim">tests/intent/ActivityTest.java:128: warning: [send.intent.missing.key] 
            startActivity(senderIntent1);
                          ^
There is a type mismatch in the intent types of senderIntent1 and
tests.ActivityReceiverStub.setIntent()'s intent parameter.
Key "k5" is either missing from the intent type of senderIntent1, or should not be present in
the intent type of com.package.ActivityReceiver.receiveIntent.setIntent()'s intent parameter.

senderIntent1's intent type:
@IntentMap({@Extra(key="k2", source={ACCESS_FINE_LOCATION}, sink={})}).
tests.ActivityReceiverStub.setIntent()'s intent parameter intent type:
@IntentMap({@Extra(key="k5", source={ACCESS_FINE_LOCATION}, sink={})}).
</pre><p>To solve this warning you need to verify how this key is used in the receiver
component, to make sure that it makes sense for the receiver to have it in its
intent type. If that is the case, you need to add an <span style="font-family:monospace">@Extra</span> with this key in the
sender&#X2019;s intent type, otherwise remove the <span style="font-family:monospace">@Extra</span> with this key from the
receiver&#X2019;s intent type.</p><p><br>
<br>
Warning: send.intent.incompatible.types:</p><pre class="verbatim">
tests/intent/ActivityTest.java:107: error: [send.intent.incompatible.types] 
            startActivity(senderIntent2);
                          ^
There is a type mismatch in the intent types of senderIntent2 and
tests.ActivityReceiverStub.setIntent()'s intent parameter. The @Extra with key "k5"
in the intent map of senderIntent2 must be a subtype of the @Extra with key "k5" in
the intent map of tests.ActivityReceiverStub.setIntent()'s intent parameter.

senderIntent2's intent type:
@IntentMap({@Extra(key="k5", source={ANY}, sink={})}).
tests.ActivityReceiverStub.setIntent()'s intent parameter intent type:
@IntentMap({@Extra(key="k5", source={ACCESS_FINE_LOCATION}, sink={})}).

</pre><p>This warning occurs when an <span style="font-family:monospace">@Extra</span> from the sender&#X2019;s intent type has
<span style="font-family:monospace">@Source</span> and/or <span style="font-family:monospace">@Sink</span> types that are not subtypes of the receiver&#X2019;s
<span style="font-family:monospace">@Extra</span> with same key.</p><p>To solve this warning you must first understand what should be the correct
intent type of both intent variables by checking how the key mentioned in the
warning is used in each component. You will need to either modify the intent type of
the sender, or the intent type of the receiver such that the <span style="font-family:monospace">@Extra</span> with the
key mentioned in the warning has the same type in both intent types. For the
example above, you could either modify the <span style="font-family:monospace">@Source</span> type of the <span style="font-family:monospace">@Extra</span> with
key <span style="font-family:monospace">"k5"</span> in <span style="font-family:monospace">senderIntent2</span>&#X2019;s intent type to <span style="font-family:monospace">ACCESS_FINE_LOCATION</span>, or
modify the <span style="font-family:monospace">@Source</span> type of the <span style="font-family:monospace">@Extra</span> with key <span style="font-family:monospace">"k5"</span> 
in <span style="font-family:monospace">onStartCommand()&#X2019;s intent parameter</span>&#X2019;s intent type to <span style="font-family:monospace">ANY</span>.</p><p><br>
<br>
Warning: intent.key.notfound:</p><pre class="verbatim"> tests/intent/ConstCheckerTest.java:44: warning: [intent.key.notfound] 
         String test1 = i1.getStringExtra("k2");
                                         ^
Invalid access: key "k2" is not in the @IntentMap annotation of i1.
</pre><p>This warning occurs when a key <span style="font-family:monospace">"k"</span> is not in the intent
type of an intent variable <span style="font-family:monospace">i</span> and either <span style="font-family:monospace">i.getExtra("k")</span> or 
<span style="font-family:monospace">i.putExtra("k",...)</span> is called.</p><p><br>
<br>
Warning: argument.type.incompatible:</p><pre class="verbatim"> IntentMapBottomTest.java:60: warning: [argument.type.incompatible] 
 incompatible types in argument.
         intentMapBottom1.putExtra("RandomKey1", getFile());
                                                         ^
found   : @Sink(FlowPermission.INTERNET) @Source(FlowPermission.FILESYSTEM) String
required: @Sink(FlowPermission.ANY) @Source({}) String
</pre><p>This warning occurs when an object is inserted into an intent&#X2019;s map but it
does not have the expected <span style="font-family:monospace">@Source</span> and/or <span style="font-family:monospace">@Sink</span> type according the
intent type.</p><p>To solve this warning you must first understand the <span style="font-family:monospace">@Source</span> and <span style="font-family:monospace">@Sink</span>
types of the object that is being inserted in the intent and annotate it
correctly. After that, you should modify the <span style="font-family:monospace">@Extra</span> of the
intent type with that key so that the type of <span style="font-family:monospace">@Extra</span> will match the object&#X2019;s
type. Considering the example above, you could either modify the <span style="font-family:monospace">@Extra</span> with
key <span style="font-family:monospace">"RandomKey1"</span> to have its <span style="font-family:monospace">@Source</span> as <span style="font-family:monospace">FILESYSTEM</span> and its <span style="font-family:monospace">@Sink</span> as
<span style="font-family:monospace">INTERNET</span>, or annotate the return type of
<span style="font-family:monospace">getFile()</span> with <span style="font-family:monospace">@Source()</span> and <span style="font-family:monospace">@Sink(ANY)</span>.</p>
<!--TOC subsection id="sec:trace-types" Trace information flows-->
<h3 id="sec:trace-types" class="subsection">6.3.6&#XA0;&#XA0;Trace information flows</h3><!--SEC END --><p>On execution, the Information Flow Checker creates a file called <span style="font-family:monospace">forbiddenFlows.txt</span> in the 
<span style="font-family:monospace">sparta-out</span> directory. This file contains a summary of all of the information flows
in the app that did not have a flow-policy entry when the Information Flow Checker was ran.
<span style="font-family:monospace">forbiddenFlows.txt</span> is recreated on every execution.</p><p>The Information Flow Checker caches the warning for each use of a forbidden flow.
This cache of flow warnings can be filtered, called flow-filtering, using the command:</p><pre class="verbatim">  ant filter-flows -Dfilter="SOURCE -&gt; SINK"
</pre><ul class="itemize"><li class="li-itemize"><span style="font-family:monospace">SOURCE</span> and <span style="font-family:monospace">SINK</span> should be replaced with the desired sensitive flow
permission to search for.</li><li class="li-itemize"><span style="font-family:monospace">SOURCE</span> and <span style="font-family:monospace">SINK</span> can be the exact name of a flow permission or a regular
expression.</li><li class="li-itemize">The -&gt; is required. However only one of <span style="font-family:monospace">SOURCE</span> or <span style="font-family:monospace">SINK</span> are required.
</li></ul><p>To start tracing information flows, begin by running the Information Flow Checker:</p><pre class="verbatim">  ant check-flow
</pre><p>Next, inspect the <span style="font-family:monospace">forbiddenFlows.txt</span> file. </p><ul class="itemize"><li class="li-itemize">
If the flow is a desired information flow, add it to the flow-policy file.
</li><li class="li-itemize">If the flow is a undesired information flow, do not add it to the flow-policy,
but record both in the source code and elsewhere that you have found a security flaw.
</li></ul><p>After evaluating all flows, select a source from the <span style="font-family:monospace">forbiddenFlows.txt</span> to trace.
Use flow filtering to display
all forbidden flow locations for the selected source.</p><pre class="verbatim">  ant command filter-flows -Dflow-filter="CAMERA -&gt;"
</pre><p>Flow-filtering displays the source code locations of forbidden flows in the app.
Inspect each source location and resolve the forbidden flow by adding annotations
or suppressing warnings as described in Section&#XA0;<a href="#sec%3Arun-type-checker">6.3.3</a>.</p><p>Iteratively run the flow-checker, check the <span style="font-family:monospace">forbiddenFlows.txt</span> file, and use flow-filtering
to trace forbidden flows throughout the app. Eventually the selected source will flow
to one or more concrete sinks. Again, determine if these flow should be added to the flow-policy
or marked as malicious.</p><p>After adding a flow to the flow-policy and rerunning the Information Flow Checker, the flow
will no longer appear in the <span style="font-family:monospace">forbiddenFlows.txt</span> file. Select another sensitive
source file to trace and begin the process again.</p><p>Repeat the tracing process until there are no more errors, or until you find bad code
(malicious, or buggy and prone to abuse).</p>
<!--TOC subsection id="sec75" Type-check with stricter checking-->
<h3 id="sec75" class="subsection">6.3.7&#XA0;&#XA0;Type-check with stricter checking</h3><!--SEC END --><p>Once all warnings were resolved, run </p><pre class="verbatim">  ant -Dsound=true check-flow
</pre><p>Providing the <span style="font-family:monospace">sound</span> option enables additional checks that are
required for soundness, but would be disruptive to enable initially.
In particular, the tests for casts and array subtyping are stricter.
See the discussion in Chapter&#XA0;<a href="#flow-checker">3</a>.</p><hr>
<!--TOC chapter id="tutorial" Tutorial-->
<h1 id="tutorial" class="chapter">Chapter&#XA0;7&#XA0;&#XA0;Tutorial</h1><!--SEC END --><p>This chapter demonstrates how to annotate an existing app, ContactManger,
where the annotator did not develop the app and the app is assumed to be benign.
ContactManger allows the user to view and create contacts that are associate 
with different accounts. </p>
<!--TOC section id="sec77" Set up-->
<h2 id="sec77" class="section">7.1&#XA0;&#XA0;Set up</h2><!--SEC END --><p>
Download the ContactManager app here: <a href="http://types.cs.washington.edu/sparta/tutorial/ContactManager.tgz"><span style="font-family:monospace">http://types.cs.washington.edu/sparta/tutorial/ContactManager.tgz</span></a>
Install the Information Flow Checker and set up ContactManger to use the Information Flow Checker. 
See Section&#XA0;<a href="#sec%3Aantsetup">2.3</a> and Section&#XA0;<a href="#sec%3Ainstall">2.2</a> for instructions. Also, install the inference framework
see Section&#XA0;<a href="#">??</a> for details.</p><p>Infer types, <span style="font-family:monospace">ant infer</span>.
Then, run the Information Flow Checker, <span style="font-family:monospace">ant check-flow-pp</span>, if the output is similar to 
the output shown below, then your setup is correct. (You should get 31 warnings.)</p><pre class="verbatim">Buildfile: .../ContactManager/build.xml
...
check-flow-pp:
Compiling 4 source files to /Users/smillst/Downloads/ContactManager/bin/classes
javac 1.8.0-jsr308-1.8.2
.../ContactAdder.java:64: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList&lt;@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer&gt; mContactEmailTypes;
                                            ^
  flow forbidden by flow-policy
  found:  { ANY  -&gt;  CONTENT_PROVIDER }  Integer
  forbidden flows:
    ANY -&gt; CONTENT_PROVIDER
</pre>
<!--TOC section id="sec78" Drafting a flow policy-->
<h2 id="sec78" class="section">7.2&#XA0;&#XA0;Drafting a flow policy</h2><!--SEC END --><p>The Information Flow Checker outputs a file, <span style="font-family:monospace">sparta-out/forbiddenFlows.txt</span>, that lists all the flows
it found in the app that are not allowed by the current flow policy. For this app, 
<span style="font-family:monospace">forbiddenFlows.txt</span> is shown below. </p><pre class="verbatim"> 
# Flows currently forbidden
 ANY -&gt; CONTENT_PROVIDER
 CONTENT_PROVIDER -&gt; DISPLAY
 USER_INPUT -&gt; WRITE_LOGS, CONTENT_PROVIDER
</pre><p>Because this app does not yet have a flow policy, this file lists all the flows that the 
Information Flow Checker was able to detect. This is not a complete list of flows in the program,
because the Information Flow Checker issued warnings, but it offers a good starting point 
for the flow policy. Because some of the inserted annotations are too permissive, so of the forbidden
flows involve <span style="font-size:small">ANY</span>. </p><p>Create a file named <span style="font-family:monospace">flow-policy</span> in the ContactManger directory. Copy all the flows that 
do not flow to or from <span style="font-size:small">ANY</span>. These flows should not be copied because 
they are too permissive. So, for this app the initial flow policy is shown below.
</p><pre class="verbatim"> 
 CONTENT_PROVIDER -&gt; DISPLAY
 USER_INPUT -&gt; WRITE_LOGS, CONTENT_PROVIDER
</pre><p>Run the Information Flow Checker again. (Because you named your flow policy 
<span style="font-family:monospace">flow-policy</span>, the Information Flow Checker will automatically read it.) The Information Flow Checker should
now only report 17 warnings. The <span style="font-family:monospace">forbiddenFlows.txt</span> file should also have changed as shown
below.</p><pre class="verbatim"># Flows currently forbidden
 ANY -&gt; CONTENT_PROVIDER
</pre><p>Since this flow contains <span style="font-size:small">ANY</span>, there is nothing to add 
to the flow policy. </p><p>Because <span style="font-size:small">USER_INPUT</span>&#X2192;<span style="font-size:small">CONTENT_PROVIDER</span> and <span style="font-size:small">CONTENT_PROVIDER</span>&#X2192;<span style="font-size:small">DISPLAY</span> are legal flows,
the Information Flow Checker reports a possible transitive flow, <span style="font-size:small">USER_INPUT</span>&#X2192;<span style="font-size:small">DISPLAY</span> see Section&#XA0;<a href="#">??</a>. </p><pre class="verbatim">warning: FlowPolicy: Found transitive flow
  [USER_INPUT]-&gt;[DISPLAY]
  Please add them to the flow policy
</pre><p>Add <span style="font-size:small">USER_INPUT</span>&#X2192;<span style="font-size:small">DISPLAY</span> to the flow policy.</p>
<!--TOC section id="sec79" Correcting Annotations-->
<h2 id="sec79" class="section">7.3&#XA0;&#XA0;Correcting Annotations</h2><!--SEC END --><p>
Inference sometimes inserts annotations that are correct, but too permissive. 
It may infer the <span style="font-size:small">ANY</span> instead of a more specific permission. Because we did
not add any flow with <span style="font-size:small">ANY</span> to the flow policy, all uses of these types will 
issue a forbidden flow warning. </p><p>Run the Information Flow Checker and filter for forbidden flows.</p><pre class="verbatim">ant check-flow -DcfOpts=-AmsgFilter=forbidden.flow
</pre><pre class="verbatim">.../ContactAdder.java:64: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList&lt;@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer&gt; mContactEmailTypes;
                                            ^
  flow forbidden by flow-policy
  found: @Sink(FlowPermission.CONTENT_PROVIDER) @Source(FlowPermission.ANY) Integer
  forbidden flows:
    ANY -&gt; CONTENT_PROVIDER
.../ContactAdder.java:68: warning: [forbidden.flow]
    private @Source({}) @Sink({}) ArrayList&lt;@Source({FlowPermission.ANY}) @Sink({FlowPermission.CONTENT_PROVIDER}) Integer&gt; mContactPhoneTypes;
                                            ^
  flow forbidden by flow-policy
  found: @Sink(FlowPermission.CONTENT_PROVIDER) @Source(FlowPermission.ANY) Integer
  forbidden flows:
    ANY -&gt; CONTENT_PROVIDER
</pre><p>Remove <span style="font-family:monospace">@Source(</span><span style="font-family:monospace">FlowPermission.ANY</span><span style="font-family:monospace">)</span> from both locations. </p>
<!--TOC section id="sec80" Adding Annotations-->
<h2 id="sec80" class="section">7.4&#XA0;&#XA0;Adding Annotations</h2><!--SEC END --><p>Next, annotate the code to ensure the flow policy correctly represents the flows
in the app. One way to annotate an unfamiliar app, is to work through each warning
one by one. Correct it by adding annotations, re-running the Information Flow Checker, 
and then correct the next warning. In general, 
Information Flow Checker warnings are written as shown below.</p><pre class="verbatim">  
../SomeClass.java:line number: warning: some types are incompatible 
             source code causing warning
                     a caret (^) pointing to the location of the warning.
   found   : Qualified type found by the Information Flow Checker
   required: Qualified type that the Information Flow Checker was expecting.
</pre><p>In order to correct a warning and correctly capture the app behavior, answer 
the following questions for each warning.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Why are the found and required annotations those listed in the warning message?
<ul class="itemize"><li class="li-itemize">
Is the annotation explicitly written in the source code? 
</li><li class="li-itemize">Is the annotation from an API method that was annotated in stub file? Section&#XA0;<a href="#sec%3Aapispecs">3.7</a>
</li><li class="li-itemize">Is the annotation inferred? Section&#XA0;<a href="#sec%3Atype-inference">3.5.1</a>
</li><li class="li-itemize">Is the annotation defaulted? Section&#XA0;<a href="#sec%3Aunannotated-types">3.5.3</a>
</li></ul>
</li><li class="li-enumerate">Why is the found type not a subtype of the required type? Section&#XA0;<a href="#sec%3Asubtyping">3.1.2</a>
<ul class="itemize"><li class="li-itemize">
Does the found type have more or different found sources than required?
</li><li class="li-itemize">Does the found type have less or different found sinks than required? 
</li></ul>
</li><li class="li-enumerate">What annotation or annotations correctly capture the behavior of the app at
this location? (In other words, what annotation will make the found type a 
subtype of the required type?)
<ul class="itemize"><li class="li-itemize">
Add only a source or a sink annotation
</li></ul>
</li></ol><p>This tutorial only covers incompatibility warnings.</p>
<!--TOC subsection id="sec81" Warning 1-->
<h3 id="sec81" class="subsection">7.4.1&#XA0;&#XA0;Warning 1</h3><!--SEC END --><p>
Run the Information Flow Checker again.</p><pre class="verbatim">  
.../ContactAdder.java:96: warning: [assignment.type.incompatible] incompatible types in assignment.
        mContactPhoneTypes = new ArrayList&lt;Integer&gt;();
                             ^
  found   :  {   -&gt;  ANY } ArrayList&lt; {   -&gt;   }  Integer&gt;
  required:  {   -&gt;   } ArrayList&lt; { USER_INPUT  -&gt;  CONTENT_PROVIDER }  Integer&gt;
</pre><p>This is an &#X201C;incompatible types in assignment&#X201D; error. It means that the type
of the left hand side, the found type, is not a subtype of the right hand side,
the required type.</p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-weight:bold">Where do the found and required types come from?</span><p>The type of <span style="font-family:monospace">new ArrayList&lt;Integer&gt;()</span> is the <em>found</em> type and the type of <span style="font-family:monospace">mContactPhoneTypes</span> is
the <em>required</em> type. </p><ul class="itemize"><li class="li-itemize">
Was it explicitly annotated in the source code? <span style="font-family:monospace">mContactPhoneTypes</span> was, but <span style="font-family:monospace">new ArrayList&lt;Integer&gt;()</span> was not.
</li><li class="li-itemize">Is it from an API method that was annotated in stub file? No
</li><li class="li-itemize">Was it inferred from an assignment? No
</li><li class="li-itemize">Was it defaulted? Yes, <span style="font-family:monospace">new ArrayList&lt;Integer&gt;()</span> 
</li></ul><p>According to the defaulting rules explained in Section&#XA0;<a href="#sec%3Aunannotated-types">3.5.3</a> constructor results
are annotated with <span style="font-family:monospace">@Source({}) @Sink({})</span> and type arguments are annotated 
with <span style="font-family:monospace">@Source({}) @Sink({})</span> by 
default. Notice that the source annotation on <span style="font-family:monospace">mContactPhoneTypes</span> has been defaulted based on the 
flow policy. <span style="font-size:small">USER_INPUT</span> is the only source allowed to flow to <span style="font-size:small">CONTENT_PROVIDER</span>. </p></li><li class="li-enumerate"><span style="font-weight:bold"> Why is the found type not a subtype of the required type?</span>
The primary qualifiers on <span style="font-family:monospace">mContactPhoneTypes</span>, <span style="font-family:monospace">@Source({}) @Sink({})</span> 
is a super type of the primary qualifiers on <span style="font-family:monospace">new ArrayList&lt;Integer&gt;()</span>,
<span style="font-family:monospace">@Source({}) @Sink(ANY)</span>. The qualifiers on the type arguments must be the same. 
For more details, see
<a href="http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#generics"><span style="font-family:monospace">http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#generics</span></a>.</li><li class="li-enumerate"><span style="font-weight:bold">What annotation or annotations would make the found type a subtype of the required?</span>
Because the annotations on <span style="font-family:monospace">mContactPhoneTypes</span> were inferred, annotations should be add to 
<span style="font-family:monospace">new ArrayList&lt;Integer&gt;()</span> so that the type argument matches <span style="font-family:monospace">mContactPhoneTypes</span> <p><span style="font-size:small"><span style="font-family:monospace"> mContactEmailTypes = new ArrayList&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-weight:bold">@Sink(CONTENT_PROVIDER)</span></span></span><span style="font-size:small"><span style="font-family:monospace"> Integer&gt;(); </span></span><span style="font-size:small"><br>
</span></p><p><span style="font-size:small">The source annotation will be defaulted to </span><span style="font-size:small"><span style="font-family:monospace">@Source(USER_INPUT) </span></span><span style="font-size:small">.
</span></p></li></ol><p>Run the Information Flow Checker again. Only three warnings should be issued.</p>
<!--TOC subsection id="sec82" Warning 2-->
<h3 id="sec82" class="subsection">7.4.2&#XA0;&#XA0;Warning 2</h3><!--SEC END --><pre class="verbatim">.../ContactAdder.java:101: warning: [assignment.type.incompatible] incompatible types in assignment.
        mContactEmailTypes = new ArrayList&lt;Integer&gt;();
                             ^
  found   :  {   -&gt;  ANY } ArrayList&lt; {   -&gt;   }  Integer&gt;
  required:  {   -&gt;   } ArrayList&lt; { USER_INPUT  -&gt;  CONTENT_PROVIDER }  Integer&gt;
</pre><p>This warning is nearly identical to the previous warning and can be corrected the same way.</p><p>Run the Information Flow Checker again. Only two errors should be issued.</p>
<!--TOC subsection id="sec83" Warning 3 -->
<h3 id="sec83" class="subsection">7.4.3&#XA0;&#XA0;Warning 3 </h3><!--SEC END --><pre class="verbatim">.../ContactAdder.java:262: warning: [argument.type.incompatible] incompatible types in argument.
                    accountTypes);
                    ^
  found   :  {   -&gt;   } AuthenticatorDescription  {   -&gt;  ANY }  []
  required:  {   -&gt;  ANY } AuthenticatorDescription  {   -&gt;  ANY }  []
</pre><p>This is an &#X201C;incompatible types in argument&#X201D; warning. It means that the type
of argument, the found type, is not a subtype of the formal parameter 
of the method, the required type.</p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-weight:bold">Where do the found and required types come from?</span>
The found type is the type the local variable , <span style="font-family:monospace">accountTypes</span> . The annotation on the array type 
(i.e. the annotation before <span style="font-family:monospace">[]</span>) was refined after the assignment on line 254. Annotations on the element 
array types (i.e. the annotation before <span style="font-family:monospace">AuthenticatorDescription</span>) are never refined, so this annotation was 
defaulted. <p>The required type is the type of the <span style="font-family:monospace">dictionary</span> parameter of the method <span style="font-family:monospace">getAuthenticatorDescription</span>. 
The source annotation were inferred, but the sink annotations were not. </p></li><li class="li-enumerate"><span style="font-weight:bold">Why is the found type not a subtype of the required type? </span>
The element array types are not equal.</li><li class="li-enumerate"><span style="font-weight:bold">What annotation or annotations would make the found type a subtype of the required?</span>
Either the declaration of <span style="font-family:monospace">accountTypes</span> needs its array elements type annotated with <span style="font-family:monospace">@Sink(ANY)</span> 
or the del cation of the <span style="font-family:monospace">dictionary</span> needs its array elements type annotated with <span style="font-family:monospace">@Sink({})</span> . 
If the type of <span style="font-family:monospace">accountTypes</span> is changed the assignment on line 256 will fail. Because of this and 
because the <span style="font-family:monospace">@Sink({})</span> is less permissive, the method signature should be update.<p>The inference tool did not infer any sink annotation for this method, so they should be add to all types.</p><p><span style="font-size:small"><span style="font-family:monospace"> private static @Source({}) </span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-weight:bold">@Sink({})</span></span></span><span style="font-size:small"><span style="font-family:monospace"> AuthenticatorDescription getAuthenticatorDescription(@Source({}) </span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-weight:bold">@Sink({})</span></span></span><span style="font-size:small"><span style="font-family:monospace"> String type,
		 @Source({}) </span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-weight:bold">@Sink({})</span></span></span><span style="font-size:small"><span style="font-family:monospace">
		 AuthenticatorDescription @Source({}) </span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-weight:bold">@Sink({})</span></span></span><span style="font-size:small"><span style="font-family:monospace"> [] dictionary) </span></span><span style="font-size:small"><br>
</span></p></li></ol><p>Run the Information Flow Checker; there should be 1 warning.</p>
<!--TOC subsection id="sec84" Warning 4 -->
<h3 id="sec84" class="subsection">7.4.4&#XA0;&#XA0;Warning 4 </h3><!--SEC END --><pre class="verbatim">.../ContactAdder.java:313: warning: [assignment.type.incompatible] incompatible types in assignment.
            mName = name;
                    ^
  found   :  {   -&gt;   }  String
  required:  {   -&gt;  CONTENT_PROVIDER, DISPLAY, WRITE_LOGS }  String
 </pre><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-weight:bold">Where do the found and required types come from?</span>
The found type is a parameter that is annotated and the required type is a field. Both 
types were inferred.
</li><li class="li-enumerate"><span style="font-weight:bold"> Why is the found type not a subtype of the required type?</span>
The found type sink does not include and the required sinks is <span style="font-size:small">CONTENT_PROVIDER</span>, 
<span style="font-size:small">DISPLAY</span>, <span style="font-size:small">WRITE_LOGS </span>. 
</li><li class="li-enumerate"><span style="font-weight:bold">What annotation or annotations would make the found type a subtype of the required?</span>
Assuming the inferred annotations on the field are correct, the annotation on the parameter should be 
updated to include the required sinks.
</li></ol><p>Run the Information Flow Checker; there should be no warnings.</p>
<!--TOC section id="sec85" Correctly annotated app-->
<h2 id="sec85" class="section">7.5&#XA0;&#XA0;Correctly annotated app</h2><!--SEC END --><p> 
Now that the Information Flow Checker no longer reports any warnings, it guarantees that
ContactManger only contains the information flows in the flow policy. </p><hr><!--TOC chapter id="sec86" References-->
<h1 id="sec86" class="chapter">References</h1><!--SEC END --><dl class="thebibliography"><dt class="dt-thebibliography">
<a id="DietlDEMS2011">[DDE<sup>+</sup>11]</a></dt><dd class="dd-thebibliography">
Werner Dietl, Stephanie Dietzel, Michael&#XA0;D. Ernst, Kivan&#XE7; Mu&#X15F;lu,
and Todd Schiller.
Building and using pluggable type-checkers.
In <em>ICSE&#X2019;11, Proceedings of the 33rd International Conference on
Software Engineering</em>, pages 681&#X2013;690, Waikiki, Hawaii, USA, May&#XA0;25&#X2013;27,
2011.</dd><dt class="dt-thebibliography"><a id="PapiACPE2008">[PAC<sup>+</sup>08]</a></dt><dd class="dd-thebibliography">
Matthew&#XA0;M. Papi, Mahmood Ali, Telmo&#XA0;Luis Correa&#XA0;Jr., Jeff&#XA0;H. Perkins, and
Michael&#XA0;D. Ernst.
Practical pluggable types for Java.
In <em>ISSTA 2008, Proceedings of the 2008 International Symposium
on Software Testing and Analysis</em>, pages 201&#X2013;212, Seattle, WA, USA,
July&#XA0;22&#X2013;24, 2008.</dd></dl><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</body>
</html>
